/* tslint:disable */
/* eslint-disable */
/**
 * neurostore api
 * Create studysets for meta-analysis
 *
 * The version of the OpenAPI document: 1.0
 * Contact: jamesdkent21@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AnalysisBase
 */
export interface AnalysisBase {
    /**
     * A name of the contrast being performed.
     * @type {string}
     * @memberof AnalysisBase
     */
    'name'?: string | null;
    /**
     * A long form description of how the contrast was performed
     * @type {string}
     * @memberof AnalysisBase
     */
    'description'?: string | null;
    /**
     * Weight applied to each condition, must be the same length as the conditions attribute.
     * @type {Array<number>}
     * @memberof AnalysisBase
     */
    'weights'?: Array<number>;
}
/**
 * attributes common between request and return objects
 * @export
 * @interface AnalysisCommon
 */
export interface AnalysisCommon {
    /**
     * 
     * @type {string}
     * @memberof AnalysisCommon
     */
    'study'?: string;
    /**
     * 
     * @type {Array<Entity>}
     * @memberof AnalysisCommon
     */
    'entities'?: Array<Entity>;
    /**
     * 
     * @type {number}
     * @memberof AnalysisCommon
     */
    'order'?: number | null;
    /**
     * 
     * @type {object}
     * @memberof AnalysisCommon
     */
    'metadata'?: object | null;
}
/**
 * 
 * @export
 * @interface AnalysisList
 */
export interface AnalysisList {
    /**
     * 
     * @type {Metadata}
     * @memberof AnalysisList
     */
    'metadata'?: Metadata;
    /**
     * 
     * @type {Array<AnalysisReturn>}
     * @memberof AnalysisList
     */
    'results'?: Array<AnalysisReturn>;
}
/**
 * 
 * @export
 * @interface AnalysisRequest
 */
export interface AnalysisRequest {
    /**
     * A name of the contrast being performed.
     * @type {string}
     * @memberof AnalysisRequest
     */
    'name'?: string | null;
    /**
     * A long form description of how the contrast was performed
     * @type {string}
     * @memberof AnalysisRequest
     */
    'description'?: string | null;
    /**
     * Weight applied to each condition, must be the same length as the conditions attribute.
     * @type {Array<number>}
     * @memberof AnalysisRequest
     */
    'weights'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof AnalysisRequest
     */
    'study'?: string;
    /**
     * 
     * @type {AnalysisRequestRelationshipsImages}
     * @memberof AnalysisRequest
     */
    'images'?: AnalysisRequestRelationshipsImages;
    /**
     * 
     * @type {AnalysisRequestRelationshipsPoints}
     * @memberof AnalysisRequest
     */
    'points'?: AnalysisRequestRelationshipsPoints;
    /**
     * 
     * @type {AnalysisRequestRelationshipsConditions}
     * @memberof AnalysisRequest
     */
    'conditions'?: AnalysisRequestRelationshipsConditions;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof AnalysisRequest
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof AnalysisRequest
     */
    'public'?: boolean;
    /**
     * 
     * @type {Array<Entity>}
     * @memberof AnalysisRequest
     */
    'entities'?: Array<Entity>;
    /**
     * 
     * @type {number}
     * @memberof AnalysisRequest
     */
    'order'?: number | null;
    /**
     * 
     * @type {object}
     * @memberof AnalysisRequest
     */
    'metadata'?: object | null;
}
/**
 * 
 * @export
 * @interface AnalysisRequestRelationships
 */
export interface AnalysisRequestRelationships {
    /**
     * 
     * @type {string}
     * @memberof AnalysisRequestRelationships
     */
    'study'?: string;
    /**
     * 
     * @type {AnalysisRequestRelationshipsImages}
     * @memberof AnalysisRequestRelationships
     */
    'images'?: AnalysisRequestRelationshipsImages;
    /**
     * 
     * @type {AnalysisRequestRelationshipsPoints}
     * @memberof AnalysisRequestRelationships
     */
    'points'?: AnalysisRequestRelationshipsPoints;
    /**
     * 
     * @type {AnalysisRequestRelationshipsConditions}
     * @memberof AnalysisRequestRelationships
     */
    'conditions'?: AnalysisRequestRelationshipsConditions;
}
/**
 * @type AnalysisRequestRelationshipsConditions
 * @export
 */
export type AnalysisRequestRelationshipsConditions = Array<ConditionRequest> | Array<string>;

/**
 * @type AnalysisRequestRelationshipsImages
 * @export
 */
export type AnalysisRequestRelationshipsImages = Array<ImageRequest> | Array<string>;

/**
 * @type AnalysisRequestRelationshipsPoints
 * @export
 */
export type AnalysisRequestRelationshipsPoints = Array<PointRequest> | Array<string>;

/**
 * 
 * @export
 * @interface AnalysisReturn
 */
export interface AnalysisReturn {
    /**
     * A name of the contrast being performed.
     * @type {string}
     * @memberof AnalysisReturn
     */
    'name'?: string | null;
    /**
     * A long form description of how the contrast was performed
     * @type {string}
     * @memberof AnalysisReturn
     */
    'description'?: string | null;
    /**
     * Weight applied to each condition, must be the same length as the conditions attribute.
     * @type {Array<number>}
     * @memberof AnalysisReturn
     */
    'weights'?: Array<number>;
    /**
     * time the resource was created on the database
     * @type {string}
     * @memberof AnalysisReturn
     */
    'created_at'?: string;
    /**
     * when the resource was last modified/updated.
     * @type {string}
     * @memberof AnalysisReturn
     */
    'updated_at'?: string | null;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof AnalysisReturn
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof AnalysisReturn
     */
    'public'?: boolean;
    /**
     * who owns the resource
     * @type {string}
     * @memberof AnalysisReturn
     */
    'user'?: string | null;
    /**
     * human readable username
     * @type {string}
     * @memberof AnalysisReturn
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AnalysisReturn
     */
    'study'?: string;
    /**
     * 
     * @type {AnalysisReturnRelationshipsImages}
     * @memberof AnalysisReturn
     */
    'images'?: AnalysisReturnRelationshipsImages;
    /**
     * 
     * @type {AnalysisReturnRelationshipsPoints}
     * @memberof AnalysisReturn
     */
    'points'?: AnalysisReturnRelationshipsPoints;
    /**
     * 
     * @type {AnalysisReturnRelationshipsConditions}
     * @memberof AnalysisReturn
     */
    'conditions'?: AnalysisReturnRelationshipsConditions;
    /**
     * 
     * @type {Array<Entity>}
     * @memberof AnalysisReturn
     */
    'entities'?: Array<Entity>;
    /**
     * 
     * @type {number}
     * @memberof AnalysisReturn
     */
    'order'?: number | null;
    /**
     * 
     * @type {object}
     * @memberof AnalysisReturn
     */
    'metadata'?: object | null;
}
/**
 * 
 * @export
 * @interface AnalysisReturnRelationships
 */
export interface AnalysisReturnRelationships {
    /**
     * 
     * @type {string}
     * @memberof AnalysisReturnRelationships
     */
    'study'?: string;
    /**
     * 
     * @type {AnalysisReturnRelationshipsImages}
     * @memberof AnalysisReturnRelationships
     */
    'images'?: AnalysisReturnRelationshipsImages;
    /**
     * 
     * @type {AnalysisReturnRelationshipsPoints}
     * @memberof AnalysisReturnRelationships
     */
    'points'?: AnalysisReturnRelationshipsPoints;
    /**
     * 
     * @type {AnalysisReturnRelationshipsConditions}
     * @memberof AnalysisReturnRelationships
     */
    'conditions'?: AnalysisReturnRelationshipsConditions;
}
/**
 * @type AnalysisReturnRelationshipsConditions
 * @export
 */
export type AnalysisReturnRelationshipsConditions = Array<ConditionReturn> | Array<string>;

/**
 * @type AnalysisReturnRelationshipsImages
 * @export
 */
export type AnalysisReturnRelationshipsImages = Array<ImageReturn> | Array<string>;

/**
 * @type AnalysisReturnRelationshipsPoints
 * @export
 */
export type AnalysisReturnRelationshipsPoints = Array<PointReturn> | Array<string>;

/**
 * 
 * @export
 * @interface AnnotationBase
 */
export interface AnnotationBase {
    /**
     * Descriptive name for the annotation.
     * @type {string}
     * @memberof AnnotationBase
     */
    'name'?: string | null;
    /**
     * Long form description of the annotation.
     * @type {string}
     * @memberof AnnotationBase
     */
    'description'?: string | null;
    /**
     * object describing metadata about the annotation, such as software used or descriptions of the keys used in the annotation.
     * @type {object}
     * @memberof AnnotationBase
     */
    'metadata'?: object | null;
    /**
     * The keys (columns) in the annotation and the key\'s respective data type (such as an integer or string).
     * @type {object}
     * @memberof AnnotationBase
     */
    'note_keys'?: object | null;
}
/**
 * 
 * @export
 * @interface AnnotationCommon
 */
export interface AnnotationCommon {
    /**
     * 
     * @type {string}
     * @memberof AnnotationCommon
     */
    'studyset'?: string;
}
/**
 * exporting an annotation as a CSV for easier editing
 * @export
 * @interface AnnotationExport
 */
export interface AnnotationExport {
    /**
     * 
     * @type {object}
     * @memberof AnnotationExport
     */
    'metadata'?: object | null;
    /**
     * annotation object expressed as a CSV
     * @type {string}
     * @memberof AnnotationExport
     */
    'annotation_csv': string;
}
/**
 * 
 * @export
 * @interface AnnotationList
 */
export interface AnnotationList {
    /**
     * 
     * @type {Array<AnnotationReturn>}
     * @memberof AnnotationList
     */
    'results'?: Array<AnnotationReturn>;
    /**
     * 
     * @type {Metadata}
     * @memberof AnnotationList
     */
    'metadata'?: Metadata;
}
/**
 * @type AnnotationRequest
 * @export
 */
export type AnnotationRequest = AnnotationRequestOneOf | AnnotationReturnOneOf;

/**
 * 
 * @export
 * @interface AnnotationRequestOneOf
 */
export interface AnnotationRequestOneOf {
    /**
     * Descriptive name for the annotation.
     * @type {string}
     * @memberof AnnotationRequestOneOf
     */
    'name'?: string | null;
    /**
     * Long form description of the annotation.
     * @type {string}
     * @memberof AnnotationRequestOneOf
     */
    'description'?: string | null;
    /**
     * object describing metadata about the annotation, such as software used or descriptions of the keys used in the annotation.
     * @type {object}
     * @memberof AnnotationRequestOneOf
     */
    'metadata'?: object | null;
    /**
     * The keys (columns) in the annotation and the key\'s respective data type (such as an integer or string).
     * @type {object}
     * @memberof AnnotationRequestOneOf
     */
    'note_keys'?: object | null;
    /**
     * 
     * @type {AnnotationRequestRelationshipsNotes}
     * @memberof AnnotationRequestOneOf
     */
    'notes'?: AnnotationRequestRelationshipsNotes;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof AnnotationRequestOneOf
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof AnnotationRequestOneOf
     */
    'public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AnnotationRequestOneOf
     */
    'studyset'?: string;
}
/**
 * 
 * @export
 * @interface AnnotationRequestRelationships
 */
export interface AnnotationRequestRelationships {
    /**
     * 
     * @type {AnnotationRequestRelationshipsNotes}
     * @memberof AnnotationRequestRelationships
     */
    'notes'?: AnnotationRequestRelationshipsNotes;
}
/**
 * @type AnnotationRequestRelationshipsNotes
 * @export
 */
export type AnnotationRequestRelationshipsNotes = Array<NoteCollectionRequest> | Array<string>;

/**
 * @type AnnotationReturn
 * @export
 */
export type AnnotationReturn = AnnotationReturnOneOf | AnnotationReturnOneOf1;

/**
 * 
 * @export
 * @interface AnnotationReturnOneOf
 */
export interface AnnotationReturnOneOf {
    /**
     * 
     * @type {object}
     * @memberof AnnotationReturnOneOf
     */
    'metadata'?: object | null;
    /**
     * annotation object expressed as a CSV
     * @type {string}
     * @memberof AnnotationReturnOneOf
     */
    'annotation_csv': string;
}
/**
 * 
 * @export
 * @interface AnnotationReturnOneOf1
 */
export interface AnnotationReturnOneOf1 {
    /**
     * Descriptive name for the annotation.
     * @type {string}
     * @memberof AnnotationReturnOneOf1
     */
    'name'?: string | null;
    /**
     * Long form description of the annotation.
     * @type {string}
     * @memberof AnnotationReturnOneOf1
     */
    'description'?: string | null;
    /**
     * object describing metadata about the annotation, such as software used or descriptions of the keys used in the annotation.
     * @type {object}
     * @memberof AnnotationReturnOneOf1
     */
    'metadata'?: object | null;
    /**
     * The keys (columns) in the annotation and the key\'s respective data type (such as an integer or string).
     * @type {object}
     * @memberof AnnotationReturnOneOf1
     */
    'note_keys'?: object | null;
    /**
     * time the resource was created on the database
     * @type {string}
     * @memberof AnnotationReturnOneOf1
     */
    'created_at'?: string;
    /**
     * when the resource was last modified/updated.
     * @type {string}
     * @memberof AnnotationReturnOneOf1
     */
    'updated_at'?: string | null;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof AnnotationReturnOneOf1
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof AnnotationReturnOneOf1
     */
    'public'?: boolean;
    /**
     * who owns the resource
     * @type {string}
     * @memberof AnnotationReturnOneOf1
     */
    'user'?: string | null;
    /**
     * human readable username
     * @type {string}
     * @memberof AnnotationReturnOneOf1
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReturnOneOf1
     */
    'source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReturnOneOf1
     */
    'source_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReturnOneOf1
     */
    'source_updated_at'?: string | null;
    /**
     * 
     * @type {AnnotationReturnRelationshipsNotes}
     * @memberof AnnotationReturnOneOf1
     */
    'notes'?: AnnotationReturnRelationshipsNotes;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReturnOneOf1
     */
    'studyset'?: string;
}
/**
 * 
 * @export
 * @interface AnnotationReturnRelationships
 */
export interface AnnotationReturnRelationships {
    /**
     * 
     * @type {AnnotationReturnRelationshipsNotes}
     * @memberof AnnotationReturnRelationships
     */
    'notes'?: AnnotationReturnRelationshipsNotes;
}
/**
 * @type AnnotationReturnRelationshipsNotes
 * @export
 */
export type AnnotationReturnRelationshipsNotes = Array<NoteCollectionReturn> | Array<string>;

/**
 * @type BaseStudiesPost200Response
 * @export
 */
export type BaseStudiesPost200Response = Array<BaseStudyReturn> | BaseStudyReturn;

/**
 * @type BaseStudiesPostRequest
 * @export
 */
export type BaseStudiesPostRequest = Array<BaseStudy> | BaseStudy;

/**
 * 
 * @export
 * @interface BaseStudy
 */
export interface BaseStudy {
    /**
     * 
     * @type {object}
     * @memberof BaseStudy
     */
    'metadata'?: object | null;
    /**
     * 
     * @type {BaseStudyVersions}
     * @memberof BaseStudy
     */
    'versions'?: BaseStudyVersions;
    /**
     * 
     * @type {string}
     * @memberof BaseStudy
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseStudy
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseStudy
     */
    'publication'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseStudy
     */
    'doi'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseStudy
     */
    'pmid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseStudy
     */
    'authors'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BaseStudy
     */
    'year'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BaseStudy
     */
    'level'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseStudy
     */
    'pmcid'?: string | null;
}
/**
 * 
 * @export
 * @interface BaseStudyList
 */
export interface BaseStudyList {
    /**
     * 
     * @type {Array<BaseStudyReturn>}
     * @memberof BaseStudyList
     */
    'results'?: Array<BaseStudyReturn>;
    /**
     * 
     * @type {Metadata}
     * @memberof BaseStudyList
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface BaseStudyReturn
 */
export interface BaseStudyReturn {
    /**
     * 
     * @type {object}
     * @memberof BaseStudyReturn
     */
    'features'?: object;
    /**
     * 
     * @type {object}
     * @memberof BaseStudyReturn
     */
    'metadata'?: object | null;
    /**
     * 
     * @type {BaseStudyVersions}
     * @memberof BaseStudyReturn
     */
    'versions'?: BaseStudyVersions;
    /**
     * 
     * @type {string}
     * @memberof BaseStudyReturn
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseStudyReturn
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseStudyReturn
     */
    'publication'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseStudyReturn
     */
    'doi'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseStudyReturn
     */
    'pmid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseStudyReturn
     */
    'authors'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BaseStudyReturn
     */
    'year'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BaseStudyReturn
     */
    'level'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseStudyReturn
     */
    'pmcid'?: string | null;
    /**
     * time the resource was created on the database
     * @type {string}
     * @memberof BaseStudyReturn
     */
    'created_at'?: string;
    /**
     * when the resource was last modified/updated.
     * @type {string}
     * @memberof BaseStudyReturn
     */
    'updated_at'?: string | null;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof BaseStudyReturn
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof BaseStudyReturn
     */
    'public'?: boolean;
    /**
     * who owns the resource
     * @type {string}
     * @memberof BaseStudyReturn
     */
    'user'?: string | null;
    /**
     * human readable username
     * @type {string}
     * @memberof BaseStudyReturn
     */
    'username'?: string | null;
}
/**
 * @type BaseStudyVersions
 * @export
 */
export type BaseStudyVersions = Array<StudyReturn> | Array<string>;

/**
 * 
 * @export
 * @interface Clone
 */
export interface Clone {
    /**
     * 
     * @type {string}
     * @memberof Clone
     */
    'source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Clone
     */
    'source_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Clone
     */
    'source_updated_at'?: string | null;
}
/**
 * 
 * @export
 * @interface ConditionBase
 */
export interface ConditionBase {
    /**
     * Name of the condition being applied in the contrast, either psychological, pharmacological, or group based.
     * @type {string}
     * @memberof ConditionBase
     */
    'name'?: string | null;
    /**
     * Long form description of how the condition is operationalized and/or specific meaning.
     * @type {string}
     * @memberof ConditionBase
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface ConditionList
 */
export interface ConditionList {
    /**
     * 
     * @type {Array<ConditionReturn>}
     * @memberof ConditionList
     */
    'results'?: Array<ConditionReturn>;
    /**
     * 
     * @type {Metadata}
     * @memberof ConditionList
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface ConditionRequest
 */
export interface ConditionRequest {
    /**
     * Name of the condition being applied in the contrast, either psychological, pharmacological, or group based.
     * @type {string}
     * @memberof ConditionRequest
     */
    'name'?: string | null;
    /**
     * Long form description of how the condition is operationalized and/or specific meaning.
     * @type {string}
     * @memberof ConditionRequest
     */
    'description'?: string | null;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof ConditionRequest
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof ConditionRequest
     */
    'public'?: boolean;
}
/**
 * 
 * @export
 * @interface ConditionReturn
 */
export interface ConditionReturn {
    /**
     * Name of the condition being applied in the contrast, either psychological, pharmacological, or group based.
     * @type {string}
     * @memberof ConditionReturn
     */
    'name'?: string | null;
    /**
     * Long form description of how the condition is operationalized and/or specific meaning.
     * @type {string}
     * @memberof ConditionReturn
     */
    'description'?: string | null;
    /**
     * time the resource was created on the database
     * @type {string}
     * @memberof ConditionReturn
     */
    'created_at'?: string;
    /**
     * when the resource was last modified/updated.
     * @type {string}
     * @memberof ConditionReturn
     */
    'updated_at'?: string | null;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof ConditionReturn
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof ConditionReturn
     */
    'public'?: boolean;
    /**
     * who owns the resource
     * @type {string}
     * @memberof ConditionReturn
     */
    'user'?: string | null;
    /**
     * human readable username
     * @type {string}
     * @memberof ConditionReturn
     */
    'username'?: string | null;
}
/**
 * WARNING: not currently used. descriptor of level of analysis for a particular image/point (run, session, subject, group, meta)
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'label'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'level'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'analysis'?: string | null;
}
/**
 * 
 * @export
 * @interface ImageBase
 */
export interface ImageBase {
    /**
     * Metadata about image such as software and version used and other relevant data about how the image was produced.
     * @type {object}
     * @memberof ImageBase
     */
    'metadata'?: object | null;
    /**
     * URL to image file.
     * @type {string}
     * @memberof ImageBase
     */
    'url'?: string | null;
    /**
     * Name of the image file.
     * @type {string}
     * @memberof ImageBase
     */
    'filename'?: string | null;
    /**
     * The template space the image is in (e.g., MNI 
     * @type {string}
     * @memberof ImageBase
     */
    'space'?: string | null;
    /**
     * The values the image represents. For example, T-statistic or Z-statistic, or Betas.
     * @type {string}
     * @memberof ImageBase
     */
    'value_type'?: string | null;
    /**
     * Date the image was added.
     * @type {string}
     * @memberof ImageBase
     */
    'add_date'?: string | null;
}
/**
 * 
 * @export
 * @interface ImageCommon
 */
export interface ImageCommon {
    /**
     * 
     * @type {string}
     * @memberof ImageCommon
     */
    'analysis'?: string;
}
/**
 * 
 * @export
 * @interface ImageList
 */
export interface ImageList {
    /**
     * 
     * @type {Array<ImageReturn>}
     * @memberof ImageList
     */
    'results'?: Array<ImageReturn>;
    /**
     * 
     * @type {Metadata}
     * @memberof ImageList
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface ImageRelationships
 */
export interface ImageRelationships {
    /**
     * 
     * @type {string}
     * @memberof ImageRelationships
     */
    'analysis'?: string;
    /**
     * 
     * @type {Array<Entity>}
     * @memberof ImageRelationships
     */
    'entities'?: Array<Entity>;
    /**
     * 
     * @type {string}
     * @memberof ImageRelationships
     */
    'analysis_name'?: string | null;
}
/**
 * 
 * @export
 * @interface ImageRequest
 */
export interface ImageRequest {
    /**
     * Metadata about image such as software and version used and other relevant data about how the image was produced.
     * @type {object}
     * @memberof ImageRequest
     */
    'metadata'?: object | null;
    /**
     * URL to image file.
     * @type {string}
     * @memberof ImageRequest
     */
    'url'?: string | null;
    /**
     * Name of the image file.
     * @type {string}
     * @memberof ImageRequest
     */
    'filename'?: string | null;
    /**
     * The template space the image is in (e.g., MNI 
     * @type {string}
     * @memberof ImageRequest
     */
    'space'?: string | null;
    /**
     * The values the image represents. For example, T-statistic or Z-statistic, or Betas.
     * @type {string}
     * @memberof ImageRequest
     */
    'value_type'?: string | null;
    /**
     * Date the image was added.
     * @type {string}
     * @memberof ImageRequest
     */
    'add_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageRequest
     */
    'analysis'?: string;
    /**
     * 
     * @type {Array<Entity>}
     * @memberof ImageRequest
     */
    'entities'?: Array<Entity>;
    /**
     * 
     * @type {string}
     * @memberof ImageRequest
     */
    'analysis_name'?: string | null;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof ImageRequest
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof ImageRequest
     */
    'public'?: boolean;
}
/**
 * 
 * @export
 * @interface ImageReturn
 */
export interface ImageReturn {
    /**
     * Metadata about image such as software and version used and other relevant data about how the image was produced.
     * @type {object}
     * @memberof ImageReturn
     */
    'metadata'?: object | null;
    /**
     * URL to image file.
     * @type {string}
     * @memberof ImageReturn
     */
    'url'?: string | null;
    /**
     * Name of the image file.
     * @type {string}
     * @memberof ImageReturn
     */
    'filename'?: string | null;
    /**
     * The template space the image is in (e.g., MNI 
     * @type {string}
     * @memberof ImageReturn
     */
    'space'?: string | null;
    /**
     * The values the image represents. For example, T-statistic or Z-statistic, or Betas.
     * @type {string}
     * @memberof ImageReturn
     */
    'value_type'?: string | null;
    /**
     * Date the image was added.
     * @type {string}
     * @memberof ImageReturn
     */
    'add_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageReturn
     */
    'analysis'?: string;
    /**
     * 
     * @type {Array<Entity>}
     * @memberof ImageReturn
     */
    'entities'?: Array<Entity>;
    /**
     * 
     * @type {string}
     * @memberof ImageReturn
     */
    'analysis_name'?: string | null;
    /**
     * time the resource was created on the database
     * @type {string}
     * @memberof ImageReturn
     */
    'created_at'?: string;
    /**
     * when the resource was last modified/updated.
     * @type {string}
     * @memberof ImageReturn
     */
    'updated_at'?: string | null;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof ImageReturn
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof ImageReturn
     */
    'public'?: boolean;
    /**
     * who owns the resource
     * @type {string}
     * @memberof ImageReturn
     */
    'user'?: string | null;
    /**
     * human readable username
     * @type {string}
     * @memberof ImageReturn
     */
    'username'?: string | null;
}
/**
 * Context for the shorthand names
 * @export
 * @interface JsonLdContext
 */
export interface JsonLdContext {
    /**
     * common URI prefix for @type
     * @type {string}
     * @memberof JsonLdContext
     */
    '@vocab'?: string;
}
/**
 * 
 * @export
 * @interface NestedPutAttributes
 */
export interface NestedPutAttributes {
    /**
     * 
     * @type {string}
     * @memberof NestedPutAttributes
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface NoteCollectionBase
 */
export interface NoteCollectionBase {
    /**
     * The note will contain all note_keys as keys and have a value of either null or the value type specified in note_keys.
     * @type {object}
     * @memberof NoteCollectionBase
     */
    'note'?: object | null;
}
/**
 * 
 * @export
 * @interface NoteCollectionList
 */
export interface NoteCollectionList {
    /**
     * 
     * @type {Array<NoteCollectionReturn>}
     * @memberof NoteCollectionList
     */
    'results'?: Array<NoteCollectionReturn>;
    /**
     * 
     * @type {Metadata}
     * @memberof NoteCollectionList
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface NoteCollectionRequest
 */
export interface NoteCollectionRequest {
    /**
     * The note will contain all note_keys as keys and have a value of either null or the value type specified in note_keys.
     * @type {object}
     * @memberof NoteCollectionRequest
     */
    'note'?: object | null;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof NoteCollectionRequest
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof NoteCollectionRequest
     */
    'public'?: boolean;
}
/**
 * 
 * @export
 * @interface NoteCollectionReturn
 */
export interface NoteCollectionReturn {
    /**
     * The note will contain all note_keys as keys and have a value of either null or the value type specified in note_keys.
     * @type {object}
     * @memberof NoteCollectionReturn
     */
    'note'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof NoteCollectionReturn
     */
    'analysis'?: string;
    /**
     * 
     * @type {string}
     * @memberof NoteCollectionReturn
     */
    'analysis_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NoteCollectionReturn
     */
    'study'?: string;
    /**
     * 
     * @type {string}
     * @memberof NoteCollectionReturn
     */
    'study_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NoteCollectionReturn
     */
    'annotation'?: string;
    /**
     * 
     * @type {number}
     * @memberof NoteCollectionReturn
     */
    'study_year'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof NoteCollectionReturn
     */
    'publication'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NoteCollectionReturn
     */
    'authors'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NoteCollectionReturn
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface Pipeline
 */
export interface Pipeline {
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Pipeline
     */
    'study_dependent'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Pipeline
     */
    'ace_compatible'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Pipeline
     */
    'pubget_compatible'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'derived_from'?: string | null;
}
/**
 * 
 * @export
 * @interface PipelineConfig
 */
export interface PipelineConfig {
    /**
     * 
     * @type {string}
     * @memberof PipelineConfig
     */
    'id'?: string;
    /**
     * 
     * @type {object}
     * @memberof PipelineConfig
     */
    'config'?: object;
}
/**
 * 
 * @export
 * @interface PipelineConfigList
 */
export interface PipelineConfigList {
    /**
     * 
     * @type {Array<PipelineConfig>}
     * @memberof PipelineConfigList
     */
    'results'?: Array<PipelineConfig>;
    /**
     * 
     * @type {Metadata}
     * @memberof PipelineConfigList
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface PipelineList
 */
export interface PipelineList {
    /**
     * 
     * @type {Array<Pipeline>}
     * @memberof PipelineList
     */
    'results'?: Array<Pipeline>;
    /**
     * 
     * @type {Metadata}
     * @memberof PipelineList
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface PipelineStudyResult
 */
export interface PipelineStudyResult {
    /**
     * 
     * @type {string}
     * @memberof PipelineStudyResult
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineStudyResult
     */
    'pipeline_config_id'?: string;
    /**
     * 
     * @type {object}
     * @memberof PipelineStudyResult
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface PipelineStudyResultList
 */
export interface PipelineStudyResultList {
    /**
     * 
     * @type {Array<PipelineStudyResult>}
     * @memberof PipelineStudyResultList
     */
    'results'?: Array<PipelineStudyResult>;
    /**
     * 
     * @type {Metadata}
     * @memberof PipelineStudyResultList
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface PointBase
 */
export interface PointBase {
    /**
     * Location of the significant coordinate in three dimensional space.
     * @type {Array<number>}
     * @memberof PointBase
     */
    'coordinates'?: Array<number>;
    /**
     * Template space used to determine coordinate Examples include TAL or MNI.
     * @type {string}
     * @memberof PointBase
     */
    'space'?: string | null;
    /**
     * Method of how point was derived (e.g., center of mass)
     * @type {string}
     * @memberof PointBase
     */
    'kind'?: string | null;
    /**
     * If the point is associated with an image, this is the value the point takes in that image.
     * @type {string}
     * @memberof PointBase
     */
    'label_id'?: string | null;
}
/**
 * 
 * @export
 * @interface PointCommon
 */
export interface PointCommon {
    /**
     * 
     * @type {string}
     * @memberof PointCommon
     */
    'analysis'?: string;
    /**
     * size of the cluster in cubic millimeters
     * @type {number}
     * @memberof PointCommon
     */
    'cluster_size'?: number | null;
    /**
     * whether the reported peak is the max-peak statistic or a sub-maxmimal peak.
     * @type {boolean}
     * @memberof PointCommon
     */
    'subpeak'?: boolean | null;
    /**
     * determines the row to display the coordinate
     * @type {number}
     * @memberof PointCommon
     */
    'order'?: number | null;
}
/**
 * 
 * @export
 * @interface PointList
 */
export interface PointList {
    /**
     * 
     * @type {Array<PointReturn>}
     * @memberof PointList
     */
    'results'?: Array<PointReturn>;
    /**
     * 
     * @type {Metadata}
     * @memberof PointList
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface PointRelationships
 */
export interface PointRelationships {
    /**
     * 
     * @type {string}
     * @memberof PointRelationships
     */
    'image'?: string | null;
    /**
     * 
     * @type {PointRelationshipsValues}
     * @memberof PointRelationships
     */
    'values'?: PointRelationshipsValues;
    /**
     * 
     * @type {number}
     * @memberof PointRelationships
     */
    'x'?: number;
    /**
     * 
     * @type {number}
     * @memberof PointRelationships
     */
    'y'?: number;
    /**
     * 
     * @type {number}
     * @memberof PointRelationships
     */
    'z'?: number;
    /**
     * 
     * @type {Array<Entity>}
     * @memberof PointRelationships
     */
    'entities'?: Array<Entity>;
}
/**
 * @type PointRelationshipsValues
 * @export
 */
export type PointRelationshipsValues = Array<PointValue> | Array<string | null>;

/**
 * 
 * @export
 * @interface PointRequest
 */
export interface PointRequest {
    /**
     * Location of the significant coordinate in three dimensional space.
     * @type {Array<number>}
     * @memberof PointRequest
     */
    'coordinates'?: Array<number>;
    /**
     * Template space used to determine coordinate Examples include TAL or MNI.
     * @type {string}
     * @memberof PointRequest
     */
    'space'?: string | null;
    /**
     * Method of how point was derived (e.g., center of mass)
     * @type {string}
     * @memberof PointRequest
     */
    'kind'?: string | null;
    /**
     * If the point is associated with an image, this is the value the point takes in that image.
     * @type {string}
     * @memberof PointRequest
     */
    'label_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PointRequest
     */
    'image'?: string | null;
    /**
     * 
     * @type {PointRelationshipsValues}
     * @memberof PointRequest
     */
    'values'?: PointRelationshipsValues;
    /**
     * 
     * @type {number}
     * @memberof PointRequest
     */
    'x'?: number;
    /**
     * 
     * @type {number}
     * @memberof PointRequest
     */
    'y'?: number;
    /**
     * 
     * @type {number}
     * @memberof PointRequest
     */
    'z'?: number;
    /**
     * 
     * @type {Array<Entity>}
     * @memberof PointRequest
     */
    'entities'?: Array<Entity>;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof PointRequest
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof PointRequest
     */
    'public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PointRequest
     */
    'analysis'?: string;
    /**
     * size of the cluster in cubic millimeters
     * @type {number}
     * @memberof PointRequest
     */
    'cluster_size'?: number | null;
    /**
     * whether the reported peak is the max-peak statistic or a sub-maxmimal peak.
     * @type {boolean}
     * @memberof PointRequest
     */
    'subpeak'?: boolean | null;
    /**
     * determines the row to display the coordinate
     * @type {number}
     * @memberof PointRequest
     */
    'order'?: number | null;
}
/**
 * 
 * @export
 * @interface PointReturn
 */
export interface PointReturn {
    /**
     * Location of the significant coordinate in three dimensional space.
     * @type {Array<number>}
     * @memberof PointReturn
     */
    'coordinates'?: Array<number>;
    /**
     * Template space used to determine coordinate Examples include TAL or MNI.
     * @type {string}
     * @memberof PointReturn
     */
    'space'?: string | null;
    /**
     * Method of how point was derived (e.g., center of mass)
     * @type {string}
     * @memberof PointReturn
     */
    'kind'?: string | null;
    /**
     * If the point is associated with an image, this is the value the point takes in that image.
     * @type {string}
     * @memberof PointReturn
     */
    'label_id'?: string | null;
    /**
     * time the resource was created on the database
     * @type {string}
     * @memberof PointReturn
     */
    'created_at'?: string;
    /**
     * when the resource was last modified/updated.
     * @type {string}
     * @memberof PointReturn
     */
    'updated_at'?: string | null;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof PointReturn
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof PointReturn
     */
    'public'?: boolean;
    /**
     * who owns the resource
     * @type {string}
     * @memberof PointReturn
     */
    'user'?: string | null;
    /**
     * human readable username
     * @type {string}
     * @memberof PointReturn
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PointReturn
     */
    'image'?: string | null;
    /**
     * 
     * @type {PointRelationshipsValues}
     * @memberof PointReturn
     */
    'values'?: PointRelationshipsValues;
    /**
     * 
     * @type {number}
     * @memberof PointReturn
     */
    'x'?: number;
    /**
     * 
     * @type {number}
     * @memberof PointReturn
     */
    'y'?: number;
    /**
     * 
     * @type {number}
     * @memberof PointReturn
     */
    'z'?: number;
    /**
     * 
     * @type {Array<Entity>}
     * @memberof PointReturn
     */
    'entities'?: Array<Entity>;
    /**
     * 
     * @type {string}
     * @memberof PointReturn
     */
    'analysis'?: string;
    /**
     * size of the cluster in cubic millimeters
     * @type {number}
     * @memberof PointReturn
     */
    'cluster_size'?: number | null;
    /**
     * whether the reported peak is the max-peak statistic or a sub-maxmimal peak.
     * @type {boolean}
     * @memberof PointReturn
     */
    'subpeak'?: boolean | null;
    /**
     * determines the row to display the coordinate
     * @type {number}
     * @memberof PointReturn
     */
    'order'?: number | null;
}
/**
 * 
 * @export
 * @interface PointValue
 */
export interface PointValue {
    /**
     * 
     * @type {string}
     * @memberof PointValue
     */
    'kind'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PointValue
     */
    'value'?: number | null;
}
/**
 * common attributes for user owned resources
 * @export
 * @interface ResourceAttributes
 */
export interface ResourceAttributes {
    /**
     * time the resource was created on the database
     * @type {string}
     * @memberof ResourceAttributes
     */
    'created_at'?: string;
    /**
     * when the resource was last modified/updated.
     * @type {string}
     * @memberof ResourceAttributes
     */
    'updated_at'?: string | null;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof ResourceAttributes
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof ResourceAttributes
     */
    'public'?: boolean;
    /**
     * who owns the resource
     * @type {string}
     * @memberof ResourceAttributes
     */
    'user'?: string | null;
    /**
     * human readable username
     * @type {string}
     * @memberof ResourceAttributes
     */
    'username'?: string | null;
}
/**
 * 
 * @export
 * @interface StudyBase
 */
export interface StudyBase {
    /**
     * Digital object identifier of the study.
     * @type {string}
     * @memberof StudyBase
     */
    'doi'?: string | null;
    /**
     * Title of the study.
     * @type {string}
     * @memberof StudyBase
     */
    'name'?: string | null;
    /**
     * Metadata associated with the study not covered by the other study attributes.
     * @type {object}
     * @memberof StudyBase
     */
    'metadata'?: object | null;
    /**
     * Long form description of the study, typically the abstract.
     * @type {string}
     * @memberof StudyBase
     */
    'description'?: string | null;
    /**
     * The journal/place of publication for the study.
     * @type {string}
     * @memberof StudyBase
     */
    'publication'?: string | null;
    /**
     * If the study was published on PubMed, place the PubMed ID here.
     * @type {string}
     * @memberof StudyBase
     */
    'pmid'?: string | null;
    /**
     * The authors on the publication of this study.
     * @type {string}
     * @memberof StudyBase
     */
    'authors'?: string | null;
    /**
     * The year this study was published.
     * @type {number}
     * @memberof StudyBase
     */
    'year'?: number | null;
}
/**
 * 
 * @export
 * @interface StudyCommon
 */
export interface StudyCommon {
    /**
     * 
     * @type {string}
     * @memberof StudyCommon
     */
    'level'?: StudyCommonLevelEnum;
}

export const StudyCommonLevelEnum = {
    Group: 'group',
    Meta: 'meta'
} as const;

export type StudyCommonLevelEnum = typeof StudyCommonLevelEnum[keyof typeof StudyCommonLevelEnum];

/**
 * 
 * @export
 * @interface StudyList
 */
export interface StudyList {
    /**
     * 
     * @type {Array<StudyReturn>}
     * @memberof StudyList
     */
    'results'?: Array<StudyReturn>;
    /**
     * 
     * @type {Metadata}
     * @memberof StudyList
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface StudyRequest
 */
export interface StudyRequest {
    /**
     * Digital object identifier of the study.
     * @type {string}
     * @memberof StudyRequest
     */
    'doi'?: string | null;
    /**
     * Title of the study.
     * @type {string}
     * @memberof StudyRequest
     */
    'name'?: string | null;
    /**
     * Metadata associated with the study not covered by the other study attributes.
     * @type {object}
     * @memberof StudyRequest
     */
    'metadata'?: object | null;
    /**
     * Long form description of the study, typically the abstract.
     * @type {string}
     * @memberof StudyRequest
     */
    'description'?: string | null;
    /**
     * The journal/place of publication for the study.
     * @type {string}
     * @memberof StudyRequest
     */
    'publication'?: string | null;
    /**
     * If the study was published on PubMed, place the PubMed ID here.
     * @type {string}
     * @memberof StudyRequest
     */
    'pmid'?: string | null;
    /**
     * The authors on the publication of this study.
     * @type {string}
     * @memberof StudyRequest
     */
    'authors'?: string | null;
    /**
     * The year this study was published.
     * @type {number}
     * @memberof StudyRequest
     */
    'year'?: number | null;
    /**
     * 
     * @type {StudyRequestRelationshipsAnalyses}
     * @memberof StudyRequest
     */
    'analyses'?: StudyRequestRelationshipsAnalyses;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof StudyRequest
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof StudyRequest
     */
    'public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StudyRequest
     */
    'pmcid'?: string | null;
}
/**
 * 
 * @export
 * @interface StudyRequestRelationships
 */
export interface StudyRequestRelationships {
    /**
     * 
     * @type {StudyRequestRelationshipsAnalyses}
     * @memberof StudyRequestRelationships
     */
    'analyses'?: StudyRequestRelationshipsAnalyses;
}
/**
 * @type StudyRequestRelationshipsAnalyses
 * @export
 */
export type StudyRequestRelationshipsAnalyses = Array<AnalysisRequest> | Array<string>;

/**
 * 
 * @export
 * @interface StudyReturn
 */
export interface StudyReturn {
    /**
     * Digital object identifier of the study.
     * @type {string}
     * @memberof StudyReturn
     */
    'doi'?: string | null;
    /**
     * Title of the study.
     * @type {string}
     * @memberof StudyReturn
     */
    'name'?: string | null;
    /**
     * Metadata associated with the study not covered by the other study attributes.
     * @type {object}
     * @memberof StudyReturn
     */
    'metadata'?: object | null;
    /**
     * Long form description of the study, typically the abstract.
     * @type {string}
     * @memberof StudyReturn
     */
    'description'?: string | null;
    /**
     * The journal/place of publication for the study.
     * @type {string}
     * @memberof StudyReturn
     */
    'publication'?: string | null;
    /**
     * If the study was published on PubMed, place the PubMed ID here.
     * @type {string}
     * @memberof StudyReturn
     */
    'pmid'?: string | null;
    /**
     * The authors on the publication of this study.
     * @type {string}
     * @memberof StudyReturn
     */
    'authors'?: string | null;
    /**
     * The year this study was published.
     * @type {number}
     * @memberof StudyReturn
     */
    'year'?: number | null;
    /**
     * time the resource was created on the database
     * @type {string}
     * @memberof StudyReturn
     */
    'created_at'?: string;
    /**
     * when the resource was last modified/updated.
     * @type {string}
     * @memberof StudyReturn
     */
    'updated_at'?: string | null;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof StudyReturn
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof StudyReturn
     */
    'public'?: boolean;
    /**
     * who owns the resource
     * @type {string}
     * @memberof StudyReturn
     */
    'user'?: string | null;
    /**
     * human readable username
     * @type {string}
     * @memberof StudyReturn
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StudyReturn
     */
    'source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StudyReturn
     */
    'source_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StudyReturn
     */
    'source_updated_at'?: string | null;
    /**
     * 
     * @type {StudyReturnRelationshipsAnalyses}
     * @memberof StudyReturn
     */
    'analyses'?: StudyReturnRelationshipsAnalyses;
    /**
     * 
     * @type {Array<StudyReturnAllOfStudysets>}
     * @memberof StudyReturn
     */
    'studysets'?: Array<StudyReturnAllOfStudysets>;
    /**
     * 
     * @type {boolean}
     * @memberof StudyReturn
     */
    'has_coordinates'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StudyReturn
     */
    'has_images'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StudyReturn
     */
    'base_study'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StudyReturn
     */
    'pmcid'?: string | null;
}
/**
 * @type StudyReturnAllOfStudysets
 * @export
 */
export type StudyReturnAllOfStudysets = StudyReturnAllOfStudysetsOneOf | string;

/**
 * 
 * @export
 * @interface StudyReturnAllOfStudysetsOneOf
 */
export interface StudyReturnAllOfStudysetsOneOf {
    /**
     * 
     * @type {string}
     * @memberof StudyReturnAllOfStudysetsOneOf
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StudyReturnAllOfStudysetsOneOf
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyReturnAllOfStudysetsOneOf
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface StudyReturnRelationships
 */
export interface StudyReturnRelationships {
    /**
     * 
     * @type {StudyReturnRelationshipsAnalyses}
     * @memberof StudyReturnRelationships
     */
    'analyses'?: StudyReturnRelationshipsAnalyses;
}
/**
 * @type StudyReturnRelationshipsAnalyses
 * @export
 */
export type StudyReturnRelationshipsAnalyses = Array<AnalysisReturn> | Array<string>;

/**
 * 
 * @export
 * @interface StudysetBase
 */
export interface StudysetBase {
    /**
     * Descriptive and human readable name of the studyset.
     * @type {string}
     * @memberof StudysetBase
     */
    'name'?: string | null;
    /**
     * A longform description of the studyset.
     * @type {string}
     * @memberof StudysetBase
     */
    'description'?: string | null;
    /**
     * The journal/source the studyset is connected to if the studyset was published.
     * @type {string}
     * @memberof StudysetBase
     */
    'publication'?: string | null;
    /**
     * A DOI connected to the published studyset (may change to being automatically created so each studyset connected to a successful meta-analysis gets a DOI).
     * @type {string}
     * @memberof StudysetBase
     */
    'doi'?: string | null;
    /**
     * If the article connected to the studyset was published on PubMed, then link the ID here.
     * @type {string}
     * @memberof StudysetBase
     */
    'pmid'?: string | null;
}
/**
 * 
 * @export
 * @interface StudysetList
 */
export interface StudysetList {
    /**
     * 
     * @type {Array<StudysetReturn>}
     * @memberof StudysetList
     */
    'results'?: Array<StudysetReturn>;
    /**
     * 
     * @type {Metadata}
     * @memberof StudysetList
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface StudysetRequest
 */
export interface StudysetRequest {
    /**
     * Descriptive and human readable name of the studyset.
     * @type {string}
     * @memberof StudysetRequest
     */
    'name'?: string | null;
    /**
     * A longform description of the studyset.
     * @type {string}
     * @memberof StudysetRequest
     */
    'description'?: string | null;
    /**
     * The journal/source the studyset is connected to if the studyset was published.
     * @type {string}
     * @memberof StudysetRequest
     */
    'publication'?: string | null;
    /**
     * A DOI connected to the published studyset (may change to being automatically created so each studyset connected to a successful meta-analysis gets a DOI).
     * @type {string}
     * @memberof StudysetRequest
     */
    'doi'?: string | null;
    /**
     * If the article connected to the studyset was published on PubMed, then link the ID here.
     * @type {string}
     * @memberof StudysetRequest
     */
    'pmid'?: string | null;
    /**
     * 
     * @type {Array<object>}
     * @memberof StudysetRequest
     */
    'studies'?: Array<object>;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof StudysetRequest
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof StudysetRequest
     */
    'public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StudysetRequest
     */
    'level'?: StudysetRequestLevelEnum;
}

export const StudysetRequestLevelEnum = {
    Group: 'group',
    Meta: 'meta'
} as const;

export type StudysetRequestLevelEnum = typeof StudysetRequestLevelEnum[keyof typeof StudysetRequestLevelEnum];

/**
 * 
 * @export
 * @interface StudysetRequestRelationships
 */
export interface StudysetRequestRelationships {
    /**
     * 
     * @type {Array<any>}
     * @memberof StudysetRequestRelationships
     */
    'studies'?: Array<any>;
}
/**
 * 
 * @export
 * @interface StudysetReturn
 */
export interface StudysetReturn {
    /**
     * Descriptive and human readable name of the studyset.
     * @type {string}
     * @memberof StudysetReturn
     */
    'name'?: string | null;
    /**
     * A longform description of the studyset.
     * @type {string}
     * @memberof StudysetReturn
     */
    'description'?: string | null;
    /**
     * The journal/source the studyset is connected to if the studyset was published.
     * @type {string}
     * @memberof StudysetReturn
     */
    'publication'?: string | null;
    /**
     * A DOI connected to the published studyset (may change to being automatically created so each studyset connected to a successful meta-analysis gets a DOI).
     * @type {string}
     * @memberof StudysetReturn
     */
    'doi'?: string | null;
    /**
     * If the article connected to the studyset was published on PubMed, then link the ID here.
     * @type {string}
     * @memberof StudysetReturn
     */
    'pmid'?: string | null;
    /**
     * time the resource was created on the database
     * @type {string}
     * @memberof StudysetReturn
     */
    'created_at'?: string;
    /**
     * when the resource was last modified/updated.
     * @type {string}
     * @memberof StudysetReturn
     */
    'updated_at'?: string | null;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof StudysetReturn
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof StudysetReturn
     */
    'public'?: boolean;
    /**
     * who owns the resource
     * @type {string}
     * @memberof StudysetReturn
     */
    'user'?: string | null;
    /**
     * human readable username
     * @type {string}
     * @memberof StudysetReturn
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StudysetReturn
     */
    'source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StudysetReturn
     */
    'source_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StudysetReturn
     */
    'source_updated_at'?: string | null;
    /**
     * 
     * @type {StudysetReturnRelationshipsStudies}
     * @memberof StudysetReturn
     */
    'studies'?: StudysetReturnRelationshipsStudies;
    /**
     * 
     * @type {string}
     * @memberof StudysetReturn
     */
    'level'?: StudysetReturnLevelEnum;
}

export const StudysetReturnLevelEnum = {
    Group: 'group',
    Meta: 'meta'
} as const;

export type StudysetReturnLevelEnum = typeof StudysetReturnLevelEnum[keyof typeof StudysetReturnLevelEnum];

/**
 * 
 * @export
 * @interface StudysetReturnRelationships
 */
export interface StudysetReturnRelationships {
    /**
     * 
     * @type {StudysetReturnRelationshipsStudies}
     * @memberof StudysetReturnRelationships
     */
    'studies'?: StudysetReturnRelationshipsStudies;
}
/**
 * @type StudysetReturnRelationshipsStudies
 * @export
 */
export type StudysetReturnRelationshipsStudies = Array<StudyReturn> | Array<string>;

/**
 * 
 * @export
 * @interface StudysetsIdGet404Response
 */
export interface StudysetsIdGet404Response {
    /**
     * 
     * @type {string}
     * @memberof StudysetsIdGet404Response
     */
    'detail'?: string;
    /**
     * 
     * @type {number}
     * @memberof StudysetsIdGet404Response
     */
    'status'?: StudysetsIdGet404ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof StudysetsIdGet404Response
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudysetsIdGet404Response
     */
    'type'?: string;
}

export const StudysetsIdGet404ResponseStatusEnum = {
    NUMBER_404: 404
} as const;

export type StudysetsIdGet404ResponseStatusEnum = typeof StudysetsIdGet404ResponseStatusEnum[keyof typeof StudysetsIdGet404ResponseStatusEnum];

/**
 * 
 * @export
 * @interface StudysetsIdPut422Response
 */
export interface StudysetsIdPut422Response {
    /**
     * 
     * @type {string}
     * @memberof StudysetsIdPut422Response
     */
    'detail'?: string;
    /**
     * 
     * @type {number}
     * @memberof StudysetsIdPut422Response
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof StudysetsIdPut422Response
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudysetsIdPut422Response
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * full name of user
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'neuroid'?: string;
}
/**
 * 
 * @export
 * @interface UserList
 */
export interface UserList {
    /**
     * 
     * @type {Array<User>}
     * @memberof UserList
     */
    'results'?: Array<User>;
    /**
     * 
     * @type {Metadata}
     * @memberof UserList
     */
    'metadata'?: Metadata;
}
/**
 * common resource attributes not tied to a specific user
 * @export
 * @interface UserlessResourceAttributes
 */
export interface UserlessResourceAttributes {
    /**
     * time the resource was created on the database
     * @type {string}
     * @memberof UserlessResourceAttributes
     */
    'created_at'?: string;
    /**
     * when the resource was last modified/updated.
     * @type {string}
     * @memberof UserlessResourceAttributes
     */
    'updated_at'?: string | null;
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof UserlessResourceAttributes
     */
    'id'?: string;
    /**
     * whether the resource is listed in public searches or not
     * @type {boolean}
     * @memberof UserlessResourceAttributes
     */
    'public'?: boolean;
}

/**
 * AnalysesApi - axios parameter creator
 * @export
 */
export const AnalysesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all analyses performed across studies.
         * @summary GET list of analyses
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesGet: async (search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, nested?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analyses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete an analysis
         * @summary DELETE an analysis
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('analysesIdDelete', 'id', id)
            const localVarPath = `/analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Information pertaining to a particular analysis within a study.
         * @summary GET an analysis
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdGet: async (id: string, nested?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('analysesIdGet', 'id', id)
            const localVarPath = `/analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing analysis.
         * @summary PUT/update an analysis
         * @param {string} id 
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdPut: async (id: string, analysisRequest?: AnalysisRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('analysesIdPut', 'id', id)
            const localVarPath = `/analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create an analysis
         * @summary POST/create an analysis
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesPost: async (analysisRequest?: AnalysisRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analyses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get annotation analyses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotation-analyses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationAnalysesIdGet', 'id', id)
            const localVarPath = `/annotation-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Your PUT endpoint
         * @param {string} id 
         * @param {NoteCollectionRequest} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesIdPut: async (id: string, noteCollectionRequest?: NoteCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationAnalysesIdPut', 'id', id)
            const localVarPath = `/annotation-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noteCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint does not allow for creation, only modification of existing annotation-analyses. If you wish to create an annotation-analysis, post to the annotations endpoint and/or add the analysis to the appropriate study in the studyset, and the annotation-analysis will be created automatically. 
         * @summary Your POST endpoint
         * @param {Array<NoteCollectionRequest>} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesPost: async (noteCollectionRequest?: Array<NoteCollectionRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotation-analyses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noteCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalysesApi - functional programming interface
 * @export
 */
export const AnalysesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalysesApiAxiosParamCreator(configuration)
    return {
        /**
         * List all analyses performed across studies.
         * @summary GET list of analyses
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, nested?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesGet(search, sort, page, desc, pageSize, name, description, nested, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysesApi.analysesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete an analysis
         * @summary DELETE an analysis
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysesApi.analysesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Information pertaining to a particular analysis within a study.
         * @summary GET an analysis
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesIdGet(id: string, nested?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesIdGet(id, nested, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysesApi.analysesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing analysis.
         * @summary PUT/update an analysis
         * @param {string} id 
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesIdPut(id: string, analysisRequest?: AnalysisRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesIdPut(id, analysisRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysesApi.analysesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create an analysis
         * @summary POST/create an analysis
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesPost(analysisRequest?: AnalysisRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesPost(analysisRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysesApi.analysesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get annotation analyses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationAnalysesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteCollectionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationAnalysesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysesApi.annotationAnalysesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationAnalysesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteCollectionReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationAnalysesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysesApi.annotationAnalysesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Your PUT endpoint
         * @param {string} id 
         * @param {NoteCollectionRequest} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationAnalysesIdPut(id: string, noteCollectionRequest?: NoteCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteCollectionReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationAnalysesIdPut(id, noteCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysesApi.annotationAnalysesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint does not allow for creation, only modification of existing annotation-analyses. If you wish to create an annotation-analysis, post to the annotations endpoint and/or add the analysis to the appropriate study in the studyset, and the annotation-analysis will be created automatically. 
         * @summary Your POST endpoint
         * @param {Array<NoteCollectionRequest>} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationAnalysesPost(noteCollectionRequest?: Array<NoteCollectionRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NoteCollectionReturn>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationAnalysesPost(noteCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysesApi.annotationAnalysesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalysesApi - factory interface
 * @export
 */
export const AnalysesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalysesApiFp(configuration)
    return {
        /**
         * List all analyses performed across studies.
         * @summary GET list of analyses
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, nested?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<AnalysisList> {
            return localVarFp.analysesGet(search, sort, page, desc, pageSize, name, description, nested, options).then((request) => request(axios, basePath));
        },
        /**
         * delete an analysis
         * @summary DELETE an analysis
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analysesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Information pertaining to a particular analysis within a study.
         * @summary GET an analysis
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdGet(id: string, nested?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<AnalysisReturn> {
            return localVarFp.analysesIdGet(id, nested, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing analysis.
         * @summary PUT/update an analysis
         * @param {string} id 
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdPut(id: string, analysisRequest?: AnalysisRequest, options?: RawAxiosRequestConfig): AxiosPromise<AnalysisReturn> {
            return localVarFp.analysesIdPut(id, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * create an analysis
         * @summary POST/create an analysis
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesPost(analysisRequest?: AnalysisRequest, options?: RawAxiosRequestConfig): AxiosPromise<AnalysisReturn> {
            return localVarFp.analysesPost(analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get annotation analyses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesGet(options?: RawAxiosRequestConfig): AxiosPromise<NoteCollectionList> {
            return localVarFp.annotationAnalysesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<NoteCollectionReturn> {
            return localVarFp.annotationAnalysesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Your PUT endpoint
         * @param {string} id 
         * @param {NoteCollectionRequest} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesIdPut(id: string, noteCollectionRequest?: NoteCollectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<NoteCollectionReturn> {
            return localVarFp.annotationAnalysesIdPut(id, noteCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint does not allow for creation, only modification of existing annotation-analyses. If you wish to create an annotation-analysis, post to the annotations endpoint and/or add the analysis to the appropriate study in the studyset, and the annotation-analysis will be created automatically. 
         * @summary Your POST endpoint
         * @param {Array<NoteCollectionRequest>} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesPost(noteCollectionRequest?: Array<NoteCollectionRequest>, options?: RawAxiosRequestConfig): AxiosPromise<Array<NoteCollectionReturn>> {
            return localVarFp.annotationAnalysesPost(noteCollectionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalysesApi - object-oriented interface
 * @export
 * @class AnalysesApi
 * @extends {BaseAPI}
 */
export class AnalysesApi extends BaseAPI {
    /**
     * List all analyses performed across studies.
     * @summary GET list of analyses
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public analysesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, nested?: boolean, options?: RawAxiosRequestConfig) {
        return AnalysesApiFp(this.configuration).analysesGet(search, sort, page, desc, pageSize, name, description, nested, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete an analysis
     * @summary DELETE an analysis
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public analysesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return AnalysesApiFp(this.configuration).analysesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Information pertaining to a particular analysis within a study.
     * @summary GET an analysis
     * @param {string} id 
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public analysesIdGet(id: string, nested?: boolean, options?: RawAxiosRequestConfig) {
        return AnalysesApiFp(this.configuration).analysesIdGet(id, nested, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing analysis.
     * @summary PUT/update an analysis
     * @param {string} id 
     * @param {AnalysisRequest} [analysisRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public analysesIdPut(id: string, analysisRequest?: AnalysisRequest, options?: RawAxiosRequestConfig) {
        return AnalysesApiFp(this.configuration).analysesIdPut(id, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create an analysis
     * @summary POST/create an analysis
     * @param {AnalysisRequest} [analysisRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public analysesPost(analysisRequest?: AnalysisRequest, options?: RawAxiosRequestConfig) {
        return AnalysesApiFp(this.configuration).analysesPost(analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get annotation analyses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public annotationAnalysesGet(options?: RawAxiosRequestConfig) {
        return AnalysesApiFp(this.configuration).annotationAnalysesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Your GET endpoint
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public annotationAnalysesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return AnalysesApiFp(this.configuration).annotationAnalysesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Your PUT endpoint
     * @param {string} id 
     * @param {NoteCollectionRequest} [noteCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public annotationAnalysesIdPut(id: string, noteCollectionRequest?: NoteCollectionRequest, options?: RawAxiosRequestConfig) {
        return AnalysesApiFp(this.configuration).annotationAnalysesIdPut(id, noteCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint does not allow for creation, only modification of existing annotation-analyses. If you wish to create an annotation-analysis, post to the annotations endpoint and/or add the analysis to the appropriate study in the studyset, and the annotation-analysis will be created automatically. 
     * @summary Your POST endpoint
     * @param {Array<NoteCollectionRequest>} [noteCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public annotationAnalysesPost(noteCollectionRequest?: Array<NoteCollectionRequest>, options?: RawAxiosRequestConfig) {
        return AnalysesApiFp(this.configuration).annotationAnalysesPost(noteCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnnotationsApi - axios parameter creator
 * @export
 */
export const AnnotationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get annotation analyses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotation-analyses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationAnalysesIdGet', 'id', id)
            const localVarPath = `/annotation-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Your PUT endpoint
         * @param {string} id 
         * @param {NoteCollectionRequest} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesIdPut: async (id: string, noteCollectionRequest?: NoteCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationAnalysesIdPut', 'id', id)
            const localVarPath = `/annotation-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noteCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint does not allow for creation, only modification of existing annotation-analyses. If you wish to create an annotation-analysis, post to the annotations endpoint and/or add the analysis to the appropriate study in the studyset, and the annotation-analysis will be created automatically. 
         * @summary Your POST endpoint
         * @param {Array<NoteCollectionRequest>} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesPost: async (noteCollectionRequest?: Array<NoteCollectionRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotation-analyses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noteCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get annotations for an available studyset
         * @summary Your GET endpoint
         * @param {string} [studysetId] see all annotations connected to this studyset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsGet: async (studysetId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (studysetId !== undefined) {
                localVarQueryParameter['studyset_id'] = studysetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete annotation
         * @summary DELETE an annotation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsIdDelete', 'id', id)
            const localVarPath = `/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get an individual annotation
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [_export] return endpoint data in consumable/readable format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdGet: async (id: string, _export?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsIdGet', 'id', id)
            const localVarPath = `/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (_export !== undefined) {
                localVarQueryParameter['export'] = _export;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * edit an existing annotation
         * @summary Update an annotation
         * @param {string} id 
         * @param {AnnotationRequest} [annotationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdPut: async (id: string, annotationRequest?: AnnotationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsIdPut', 'id', id)
            const localVarPath = `/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an annotation
         * @summary Post Annotation
         * @param {AnnotationsPostSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {AnnotationRequest} [annotationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsPost: async (source?: AnnotationsPostSourceEnum, sourceId?: string, annotationRequest?: AnnotationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnotationsApi - functional programming interface
 * @export
 */
export const AnnotationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnotationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get annotation analyses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationAnalysesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteCollectionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationAnalysesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.annotationAnalysesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationAnalysesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteCollectionReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationAnalysesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.annotationAnalysesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Your PUT endpoint
         * @param {string} id 
         * @param {NoteCollectionRequest} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationAnalysesIdPut(id: string, noteCollectionRequest?: NoteCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteCollectionReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationAnalysesIdPut(id, noteCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.annotationAnalysesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint does not allow for creation, only modification of existing annotation-analyses. If you wish to create an annotation-analysis, post to the annotations endpoint and/or add the analysis to the appropriate study in the studyset, and the annotation-analysis will be created automatically. 
         * @summary Your POST endpoint
         * @param {Array<NoteCollectionRequest>} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationAnalysesPost(noteCollectionRequest?: Array<NoteCollectionRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NoteCollectionReturn>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationAnalysesPost(noteCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.annotationAnalysesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get annotations for an available studyset
         * @summary Your GET endpoint
         * @param {string} [studysetId] see all annotations connected to this studyset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsGet(studysetId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsGet(studysetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.annotationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete annotation
         * @summary DELETE an annotation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.annotationsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get an individual annotation
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [_export] return endpoint data in consumable/readable format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsIdGet(id: string, _export?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsIdGet(id, _export, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.annotationsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * edit an existing annotation
         * @summary Update an annotation
         * @param {string} id 
         * @param {AnnotationRequest} [annotationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsIdPut(id: string, annotationRequest?: AnnotationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsIdPut(id, annotationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.annotationsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an annotation
         * @summary Post Annotation
         * @param {AnnotationsPostSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {AnnotationRequest} [annotationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsPost(source?: AnnotationsPostSourceEnum, sourceId?: string, annotationRequest?: AnnotationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsPost(source, sourceId, annotationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.annotationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnnotationsApi - factory interface
 * @export
 */
export const AnnotationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnotationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get annotation analyses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesGet(options?: RawAxiosRequestConfig): AxiosPromise<NoteCollectionList> {
            return localVarFp.annotationAnalysesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<NoteCollectionReturn> {
            return localVarFp.annotationAnalysesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Your PUT endpoint
         * @param {string} id 
         * @param {NoteCollectionRequest} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesIdPut(id: string, noteCollectionRequest?: NoteCollectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<NoteCollectionReturn> {
            return localVarFp.annotationAnalysesIdPut(id, noteCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint does not allow for creation, only modification of existing annotation-analyses. If you wish to create an annotation-analysis, post to the annotations endpoint and/or add the analysis to the appropriate study in the studyset, and the annotation-analysis will be created automatically. 
         * @summary Your POST endpoint
         * @param {Array<NoteCollectionRequest>} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesPost(noteCollectionRequest?: Array<NoteCollectionRequest>, options?: RawAxiosRequestConfig): AxiosPromise<Array<NoteCollectionReturn>> {
            return localVarFp.annotationAnalysesPost(noteCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * get annotations for an available studyset
         * @summary Your GET endpoint
         * @param {string} [studysetId] see all annotations connected to this studyset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsGet(studysetId?: string, options?: RawAxiosRequestConfig): AxiosPromise<AnnotationList> {
            return localVarFp.annotationsGet(studysetId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete annotation
         * @summary DELETE an annotation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.annotationsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get an individual annotation
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [_export] return endpoint data in consumable/readable format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdGet(id: string, _export?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<AnnotationReturn> {
            return localVarFp.annotationsIdGet(id, _export, options).then((request) => request(axios, basePath));
        },
        /**
         * edit an existing annotation
         * @summary Update an annotation
         * @param {string} id 
         * @param {AnnotationRequest} [annotationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdPut(id: string, annotationRequest?: AnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<AnnotationReturn> {
            return localVarFp.annotationsIdPut(id, annotationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an annotation
         * @summary Post Annotation
         * @param {AnnotationsPostSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {AnnotationRequest} [annotationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsPost(source?: AnnotationsPostSourceEnum, sourceId?: string, annotationRequest?: AnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<AnnotationReturn> {
            return localVarFp.annotationsPost(source, sourceId, annotationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnotationsApi - object-oriented interface
 * @export
 * @class AnnotationsApi
 * @extends {BaseAPI}
 */
export class AnnotationsApi extends BaseAPI {
    /**
     * 
     * @summary Get annotation analyses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationAnalysesGet(options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationAnalysesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Your GET endpoint
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationAnalysesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationAnalysesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Your PUT endpoint
     * @param {string} id 
     * @param {NoteCollectionRequest} [noteCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationAnalysesIdPut(id: string, noteCollectionRequest?: NoteCollectionRequest, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationAnalysesIdPut(id, noteCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint does not allow for creation, only modification of existing annotation-analyses. If you wish to create an annotation-analysis, post to the annotations endpoint and/or add the analysis to the appropriate study in the studyset, and the annotation-analysis will be created automatically. 
     * @summary Your POST endpoint
     * @param {Array<NoteCollectionRequest>} [noteCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationAnalysesPost(noteCollectionRequest?: Array<NoteCollectionRequest>, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationAnalysesPost(noteCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get annotations for an available studyset
     * @summary Your GET endpoint
     * @param {string} [studysetId] see all annotations connected to this studyset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsGet(studysetId?: string, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsGet(studysetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete annotation
     * @summary DELETE an annotation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get an individual annotation
     * @summary Your GET endpoint
     * @param {string} id 
     * @param {boolean} [_export] return endpoint data in consumable/readable format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsIdGet(id: string, _export?: boolean, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsIdGet(id, _export, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * edit an existing annotation
     * @summary Update an annotation
     * @param {string} id 
     * @param {AnnotationRequest} [annotationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsIdPut(id: string, annotationRequest?: AnnotationRequest, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsIdPut(id, annotationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an annotation
     * @summary Post Annotation
     * @param {AnnotationsPostSourceEnum} [source] the source of the resource you would like to filter/copy from
     * @param {string} [sourceId] id of the resource you are either filtering/copying on
     * @param {AnnotationRequest} [annotationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsPost(source?: AnnotationsPostSourceEnum, sourceId?: string, annotationRequest?: AnnotationRequest, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).annotationsPost(source, sourceId, annotationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AnnotationsPostSourceEnum = {
    Neurostore: 'neurostore',
    Neurovault: 'neurovault',
    Pubmed: 'pubmed',
    Neurosynth: 'neurosynth',
    Neuroquery: 'neuroquery',
    Pubget: 'pubget'
} as const;
export type AnnotationsPostSourceEnum = typeof AnnotationsPostSourceEnum[keyof typeof AnnotationsPostSourceEnum];


/**
 * ConditionsApi - axios parameter creator
 * @export
 */
export const ConditionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all conditions
         * @summary GET Conditions
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsGet: async (search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conditions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a condition
         * @summary DELETE a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('conditionsIdDelete', 'id', id)
            const localVarPath = `/conditions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
         * @summary GET a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('conditionsIdGet', 'id', id)
            const localVarPath = `/conditions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a condition
         * @summary PUT/update a condition
         * @param {string} id 
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdPut: async (id: string, conditionRequest?: ConditionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('conditionsIdPut', 'id', id)
            const localVarPath = `/conditions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conditionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a condition
         * @summary POST/Create a condition
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsPost: async (conditionRequest?: ConditionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conditions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conditionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConditionsApi - functional programming interface
 * @export
 */
export const ConditionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConditionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all conditions
         * @summary GET Conditions
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConditionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsGet(search, sort, page, desc, pageSize, name, description, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConditionsApi.conditionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete a condition
         * @summary DELETE a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConditionsApi.conditionsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
         * @summary GET a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConditionReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConditionsApi.conditionsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update a condition
         * @summary PUT/update a condition
         * @param {string} id 
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsIdPut(id: string, conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConditionReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsIdPut(id, conditionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConditionsApi.conditionsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a condition
         * @summary POST/Create a condition
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsPost(conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConditionReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsPost(conditionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConditionsApi.conditionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConditionsApi - factory interface
 * @export
 */
export const ConditionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConditionsApiFp(configuration)
    return {
        /**
         * Get all conditions
         * @summary GET Conditions
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, options?: RawAxiosRequestConfig): AxiosPromise<ConditionList> {
            return localVarFp.conditionsGet(search, sort, page, desc, pageSize, name, description, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a condition
         * @summary DELETE a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.conditionsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
         * @summary GET a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ConditionReturn> {
            return localVarFp.conditionsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * update a condition
         * @summary PUT/update a condition
         * @param {string} id 
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdPut(id: string, conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConditionReturn> {
            return localVarFp.conditionsIdPut(id, conditionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a condition
         * @summary POST/Create a condition
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsPost(conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConditionReturn> {
            return localVarFp.conditionsPost(conditionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConditionsApi - object-oriented interface
 * @export
 * @class ConditionsApi
 * @extends {BaseAPI}
 */
export class ConditionsApi extends BaseAPI {
    /**
     * Get all conditions
     * @summary GET Conditions
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public conditionsGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, options?: RawAxiosRequestConfig) {
        return ConditionsApiFp(this.configuration).conditionsGet(search, sort, page, desc, pageSize, name, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a condition
     * @summary DELETE a condition
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public conditionsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ConditionsApiFp(this.configuration).conditionsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
     * @summary GET a condition
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public conditionsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ConditionsApiFp(this.configuration).conditionsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a condition
     * @summary PUT/update a condition
     * @param {string} id 
     * @param {ConditionRequest} [conditionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public conditionsIdPut(id: string, conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig) {
        return ConditionsApiFp(this.configuration).conditionsIdPut(id, conditionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a condition
     * @summary POST/Create a condition
     * @param {ConditionRequest} [conditionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public conditionsPost(conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig) {
        return ConditionsApiFp(this.configuration).conditionsPost(conditionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve and list images.
         * @summary GET a list of images
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [filename] search filename field
         * @param {string} [analysisName] search analysis_name field
         * @param {string} [valueType] search value_type field
         * @param {string} [space] search space field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesGet: async (search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, filename?: string, analysisName?: string, valueType?: string, space?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/images/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (analysisName !== undefined) {
                localVarQueryParameter['analysis_name'] = analysisName;
            }

            if (valueType !== undefined) {
                localVarQueryParameter['value_type'] = valueType;
            }

            if (space !== undefined) {
                localVarQueryParameter['space'] = space;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete an image
         * @summary DELETE an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesIdDelete', 'id', id)
            const localVarPath = `/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about a particular image from an analysis.
         * @summary GET an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesIdGet', 'id', id)
            const localVarPath = `/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific image.
         * @summary PUT/update an image
         * @param {string} id 
         * @param {ImageRequest} [imageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdPut: async (id: string, imageRequest?: ImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesIdPut', 'id', id)
            const localVarPath = `/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an image
         * @summary POST/create an image
         * @param {ImageRequest} [imageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesPost: async (imageRequest?: ImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/images/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve and list images.
         * @summary GET a list of images
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [filename] search filename field
         * @param {string} [analysisName] search analysis_name field
         * @param {string} [valueType] search value_type field
         * @param {string} [space] search space field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, filename?: string, analysisName?: string, valueType?: string, space?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesGet(search, sort, page, desc, pageSize, filename, analysisName, valueType, space, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete an image
         * @summary DELETE an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve information about a particular image from an analysis.
         * @summary GET an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific image.
         * @summary PUT/update an image
         * @param {string} id 
         * @param {ImageRequest} [imageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesIdPut(id: string, imageRequest?: ImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesIdPut(id, imageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an image
         * @summary POST/create an image
         * @param {ImageRequest} [imageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesPost(imageRequest?: ImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesPost(imageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * Retrieve and list images.
         * @summary GET a list of images
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [filename] search filename field
         * @param {string} [analysisName] search analysis_name field
         * @param {string} [valueType] search value_type field
         * @param {string} [space] search space field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, filename?: string, analysisName?: string, valueType?: string, space?: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageList> {
            return localVarFp.imagesGet(search, sort, page, desc, pageSize, filename, analysisName, valueType, space, options).then((request) => request(axios, basePath));
        },
        /**
         * delete an image
         * @summary DELETE an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.imagesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information about a particular image from an analysis.
         * @summary GET an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageReturn> {
            return localVarFp.imagesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific image.
         * @summary PUT/update an image
         * @param {string} id 
         * @param {ImageRequest} [imageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdPut(id: string, imageRequest?: ImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageReturn> {
            return localVarFp.imagesIdPut(id, imageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an image
         * @summary POST/create an image
         * @param {ImageRequest} [imageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesPost(imageRequest?: ImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageReturn> {
            return localVarFp.imagesPost(imageRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * Retrieve and list images.
     * @summary GET a list of images
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {string} [filename] search filename field
     * @param {string} [analysisName] search analysis_name field
     * @param {string} [valueType] search value_type field
     * @param {string} [space] search space field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, filename?: string, analysisName?: string, valueType?: string, space?: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesGet(search, sort, page, desc, pageSize, filename, analysisName, valueType, space, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete an image
     * @summary DELETE an image
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information about a particular image from an analysis.
     * @summary GET an image
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific image.
     * @summary PUT/update an image
     * @param {string} id 
     * @param {ImageRequest} [imageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesIdPut(id: string, imageRequest?: ImageRequest, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesIdPut(id, imageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an image
     * @summary POST/create an image
     * @param {ImageRequest} [imageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesPost(imageRequest?: ImageRequest, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesPost(imageRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PipelineConfigsApi - axios parameter creator
 * @export
 */
export const PipelineConfigsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary GET a list of pipeline configs
         * @param {Array<string>} [pipeline] Filter configs by pipeline name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineConfigsGet: async (pipeline?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pipeline-configs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pipeline) {
                localVarQueryParameter['pipeline'] = pipeline;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DELETE a pipeline config by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineConfigsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pipelineConfigsIdDelete', 'id', id)
            const localVarPath = `/pipeline-configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GET a pipeline config by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineConfigsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pipelineConfigsIdGet', 'id', id)
            const localVarPath = `/pipeline-configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PUT/update a pipeline config by ID
         * @param {string} id 
         * @param {PipelineConfig} [pipelineConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineConfigsIdPut: async (id: string, pipelineConfig?: PipelineConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pipelineConfigsIdPut', 'id', id)
            const localVarPath = `/pipeline-configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary POST/create a pipeline config
         * @param {PipelineConfig} [pipelineConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineConfigsPost: async (pipelineConfig?: PipelineConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pipeline-configs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelineConfigsApi - functional programming interface
 * @export
 */
export const PipelineConfigsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PipelineConfigsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary GET a list of pipeline configs
         * @param {Array<string>} [pipeline] Filter configs by pipeline name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineConfigsGet(pipeline?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineConfigList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineConfigsGet(pipeline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelineConfigsApi.pipelineConfigsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary DELETE a pipeline config by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineConfigsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineConfigsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelineConfigsApi.pipelineConfigsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary GET a pipeline config by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineConfigsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineConfigsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelineConfigsApi.pipelineConfigsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary PUT/update a pipeline config by ID
         * @param {string} id 
         * @param {PipelineConfig} [pipelineConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineConfigsIdPut(id: string, pipelineConfig?: PipelineConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineConfigsIdPut(id, pipelineConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelineConfigsApi.pipelineConfigsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary POST/create a pipeline config
         * @param {PipelineConfig} [pipelineConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineConfigsPost(pipelineConfig?: PipelineConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineConfigsPost(pipelineConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelineConfigsApi.pipelineConfigsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PipelineConfigsApi - factory interface
 * @export
 */
export const PipelineConfigsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PipelineConfigsApiFp(configuration)
    return {
        /**
         * 
         * @summary GET a list of pipeline configs
         * @param {Array<string>} [pipeline] Filter configs by pipeline name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineConfigsGet(pipeline?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<PipelineConfigList> {
            return localVarFp.pipelineConfigsGet(pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DELETE a pipeline config by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineConfigsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pipelineConfigsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GET a pipeline config by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineConfigsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PipelineConfig> {
            return localVarFp.pipelineConfigsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PUT/update a pipeline config by ID
         * @param {string} id 
         * @param {PipelineConfig} [pipelineConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineConfigsIdPut(id: string, pipelineConfig?: PipelineConfig, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pipelineConfigsIdPut(id, pipelineConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary POST/create a pipeline config
         * @param {PipelineConfig} [pipelineConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineConfigsPost(pipelineConfig?: PipelineConfig, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pipelineConfigsPost(pipelineConfig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PipelineConfigsApi - object-oriented interface
 * @export
 * @class PipelineConfigsApi
 * @extends {BaseAPI}
 */
export class PipelineConfigsApi extends BaseAPI {
    /**
     * 
     * @summary GET a list of pipeline configs
     * @param {Array<string>} [pipeline] Filter configs by pipeline name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineConfigsApi
     */
    public pipelineConfigsGet(pipeline?: Array<string>, options?: RawAxiosRequestConfig) {
        return PipelineConfigsApiFp(this.configuration).pipelineConfigsGet(pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DELETE a pipeline config by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineConfigsApi
     */
    public pipelineConfigsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return PipelineConfigsApiFp(this.configuration).pipelineConfigsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GET a pipeline config by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineConfigsApi
     */
    public pipelineConfigsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return PipelineConfigsApiFp(this.configuration).pipelineConfigsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PUT/update a pipeline config by ID
     * @param {string} id 
     * @param {PipelineConfig} [pipelineConfig] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineConfigsApi
     */
    public pipelineConfigsIdPut(id: string, pipelineConfig?: PipelineConfig, options?: RawAxiosRequestConfig) {
        return PipelineConfigsApiFp(this.configuration).pipelineConfigsIdPut(id, pipelineConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary POST/create a pipeline config
     * @param {PipelineConfig} [pipelineConfig] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineConfigsApi
     */
    public pipelineConfigsPost(pipelineConfig?: PipelineConfig, options?: RawAxiosRequestConfig) {
        return PipelineConfigsApiFp(this.configuration).pipelineConfigsPost(pipelineConfig, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PipelineStudyResultsApi - axios parameter creator
 * @export
 */
export const PipelineStudyResultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary GET a list of pipeline run results
         * @param {Array<string>} [featureFilter] Filter results by feature content. Format: \&quot;PipelineName[:version]:field_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:groups.diagnosis&#x3D;ADHD\&quot; (specific version)   - \&quot;TestPipeline:groups.diagnosis&#x3D;ADHD\&quot; (latest version)  Field path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {boolean} [featureFlatten] 
         * @param {Array<string>} [pipelineConfig] Filter results by pipeline config content. Format: \&quot;PipelineName[:version]:config_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:preprocessing.smoothing&#x3D;8\&quot; (specific version)   - \&quot;TestPipeline:model.type&#x3D;linear\&quot; (latest version)  Config path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {Array<string>} [studyId] Filter results by base study ID
         * @param {string} [version] Filter results by pipeline config version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineStudyResultsGet: async (featureFilter?: Array<string>, featureFlatten?: boolean, pipelineConfig?: Array<string>, studyId?: Array<string>, version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pipeline-study-results/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (featureFilter) {
                localVarQueryParameter['feature_filter'] = featureFilter;
            }

            if (featureFlatten !== undefined) {
                localVarQueryParameter['feature_flatten'] = featureFlatten;
            }

            if (pipelineConfig) {
                localVarQueryParameter['pipeline_config'] = pipelineConfig;
            }

            if (studyId) {
                localVarQueryParameter['study_id'] = studyId;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DELETE a pipeline run result by ID
         * @param {string} pipelineStudyResultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineStudyResultsPipelineStudyResultIdDelete: async (pipelineStudyResultId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineStudyResultId' is not null or undefined
            assertParamExists('pipelineStudyResultsPipelineStudyResultIdDelete', 'pipelineStudyResultId', pipelineStudyResultId)
            const localVarPath = `/pipeline-study-results/{pipeline_study_result_id}`
                .replace(`{${"pipeline_study_result_id"}}`, encodeURIComponent(String(pipelineStudyResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GET a pipeline run result by ID
         * @param {string} pipelineStudyResultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineStudyResultsPipelineStudyResultIdGet: async (pipelineStudyResultId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineStudyResultId' is not null or undefined
            assertParamExists('pipelineStudyResultsPipelineStudyResultIdGet', 'pipelineStudyResultId', pipelineStudyResultId)
            const localVarPath = `/pipeline-study-results/{pipeline_study_result_id}`
                .replace(`{${"pipeline_study_result_id"}}`, encodeURIComponent(String(pipelineStudyResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PUT/update a pipeline run result by ID
         * @param {string} pipelineStudyResultId 
         * @param {PipelineStudyResult} [pipelineStudyResult] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineStudyResultsPipelineStudyResultIdPut: async (pipelineStudyResultId: string, pipelineStudyResult?: PipelineStudyResult, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineStudyResultId' is not null or undefined
            assertParamExists('pipelineStudyResultsPipelineStudyResultIdPut', 'pipelineStudyResultId', pipelineStudyResultId)
            const localVarPath = `/pipeline-study-results/{pipeline_study_result_id}`
                .replace(`{${"pipeline_study_result_id"}}`, encodeURIComponent(String(pipelineStudyResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineStudyResult, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary POST/create a pipeline run result
         * @param {PipelineStudyResult} [pipelineStudyResult] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineStudyResultsPost: async (pipelineStudyResult?: PipelineStudyResult, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pipeline-study-results/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineStudyResult, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelineStudyResultsApi - functional programming interface
 * @export
 */
export const PipelineStudyResultsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PipelineStudyResultsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary GET a list of pipeline run results
         * @param {Array<string>} [featureFilter] Filter results by feature content. Format: \&quot;PipelineName[:version]:field_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:groups.diagnosis&#x3D;ADHD\&quot; (specific version)   - \&quot;TestPipeline:groups.diagnosis&#x3D;ADHD\&quot; (latest version)  Field path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {boolean} [featureFlatten] 
         * @param {Array<string>} [pipelineConfig] Filter results by pipeline config content. Format: \&quot;PipelineName[:version]:config_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:preprocessing.smoothing&#x3D;8\&quot; (specific version)   - \&quot;TestPipeline:model.type&#x3D;linear\&quot; (latest version)  Config path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {Array<string>} [studyId] Filter results by base study ID
         * @param {string} [version] Filter results by pipeline config version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineStudyResultsGet(featureFilter?: Array<string>, featureFlatten?: boolean, pipelineConfig?: Array<string>, studyId?: Array<string>, version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineStudyResultList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineStudyResultsGet(featureFilter, featureFlatten, pipelineConfig, studyId, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelineStudyResultsApi.pipelineStudyResultsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary DELETE a pipeline run result by ID
         * @param {string} pipelineStudyResultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineStudyResultsPipelineStudyResultIdDelete(pipelineStudyResultId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineStudyResultsPipelineStudyResultIdDelete(pipelineStudyResultId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelineStudyResultsApi.pipelineStudyResultsPipelineStudyResultIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary GET a pipeline run result by ID
         * @param {string} pipelineStudyResultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineStudyResultsPipelineStudyResultIdGet(pipelineStudyResultId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineStudyResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineStudyResultsPipelineStudyResultIdGet(pipelineStudyResultId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelineStudyResultsApi.pipelineStudyResultsPipelineStudyResultIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary PUT/update a pipeline run result by ID
         * @param {string} pipelineStudyResultId 
         * @param {PipelineStudyResult} [pipelineStudyResult] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineStudyResultsPipelineStudyResultIdPut(pipelineStudyResultId: string, pipelineStudyResult?: PipelineStudyResult, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineStudyResultsPipelineStudyResultIdPut(pipelineStudyResultId, pipelineStudyResult, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelineStudyResultsApi.pipelineStudyResultsPipelineStudyResultIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary POST/create a pipeline run result
         * @param {PipelineStudyResult} [pipelineStudyResult] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineStudyResultsPost(pipelineStudyResult?: PipelineStudyResult, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineStudyResultsPost(pipelineStudyResult, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelineStudyResultsApi.pipelineStudyResultsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PipelineStudyResultsApi - factory interface
 * @export
 */
export const PipelineStudyResultsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PipelineStudyResultsApiFp(configuration)
    return {
        /**
         * 
         * @summary GET a list of pipeline run results
         * @param {Array<string>} [featureFilter] Filter results by feature content. Format: \&quot;PipelineName[:version]:field_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:groups.diagnosis&#x3D;ADHD\&quot; (specific version)   - \&quot;TestPipeline:groups.diagnosis&#x3D;ADHD\&quot; (latest version)  Field path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {boolean} [featureFlatten] 
         * @param {Array<string>} [pipelineConfig] Filter results by pipeline config content. Format: \&quot;PipelineName[:version]:config_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:preprocessing.smoothing&#x3D;8\&quot; (specific version)   - \&quot;TestPipeline:model.type&#x3D;linear\&quot; (latest version)  Config path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {Array<string>} [studyId] Filter results by base study ID
         * @param {string} [version] Filter results by pipeline config version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineStudyResultsGet(featureFilter?: Array<string>, featureFlatten?: boolean, pipelineConfig?: Array<string>, studyId?: Array<string>, version?: string, options?: RawAxiosRequestConfig): AxiosPromise<PipelineStudyResultList> {
            return localVarFp.pipelineStudyResultsGet(featureFilter, featureFlatten, pipelineConfig, studyId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DELETE a pipeline run result by ID
         * @param {string} pipelineStudyResultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineStudyResultsPipelineStudyResultIdDelete(pipelineStudyResultId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pipelineStudyResultsPipelineStudyResultIdDelete(pipelineStudyResultId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GET a pipeline run result by ID
         * @param {string} pipelineStudyResultId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineStudyResultsPipelineStudyResultIdGet(pipelineStudyResultId: string, options?: RawAxiosRequestConfig): AxiosPromise<PipelineStudyResult> {
            return localVarFp.pipelineStudyResultsPipelineStudyResultIdGet(pipelineStudyResultId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PUT/update a pipeline run result by ID
         * @param {string} pipelineStudyResultId 
         * @param {PipelineStudyResult} [pipelineStudyResult] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineStudyResultsPipelineStudyResultIdPut(pipelineStudyResultId: string, pipelineStudyResult?: PipelineStudyResult, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pipelineStudyResultsPipelineStudyResultIdPut(pipelineStudyResultId, pipelineStudyResult, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary POST/create a pipeline run result
         * @param {PipelineStudyResult} [pipelineStudyResult] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineStudyResultsPost(pipelineStudyResult?: PipelineStudyResult, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pipelineStudyResultsPost(pipelineStudyResult, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PipelineStudyResultsApi - object-oriented interface
 * @export
 * @class PipelineStudyResultsApi
 * @extends {BaseAPI}
 */
export class PipelineStudyResultsApi extends BaseAPI {
    /**
     * 
     * @summary GET a list of pipeline run results
     * @param {Array<string>} [featureFilter] Filter results by feature content. Format: \&quot;PipelineName[:version]:field_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:groups.diagnosis&#x3D;ADHD\&quot; (specific version)   - \&quot;TestPipeline:groups.diagnosis&#x3D;ADHD\&quot; (latest version)  Field path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
     * @param {boolean} [featureFlatten] 
     * @param {Array<string>} [pipelineConfig] Filter results by pipeline config content. Format: \&quot;PipelineName[:version]:config_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:preprocessing.smoothing&#x3D;8\&quot; (specific version)   - \&quot;TestPipeline:model.type&#x3D;linear\&quot; (latest version)  Config path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
     * @param {Array<string>} [studyId] Filter results by base study ID
     * @param {string} [version] Filter results by pipeline config version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineStudyResultsApi
     */
    public pipelineStudyResultsGet(featureFilter?: Array<string>, featureFlatten?: boolean, pipelineConfig?: Array<string>, studyId?: Array<string>, version?: string, options?: RawAxiosRequestConfig) {
        return PipelineStudyResultsApiFp(this.configuration).pipelineStudyResultsGet(featureFilter, featureFlatten, pipelineConfig, studyId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DELETE a pipeline run result by ID
     * @param {string} pipelineStudyResultId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineStudyResultsApi
     */
    public pipelineStudyResultsPipelineStudyResultIdDelete(pipelineStudyResultId: string, options?: RawAxiosRequestConfig) {
        return PipelineStudyResultsApiFp(this.configuration).pipelineStudyResultsPipelineStudyResultIdDelete(pipelineStudyResultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GET a pipeline run result by ID
     * @param {string} pipelineStudyResultId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineStudyResultsApi
     */
    public pipelineStudyResultsPipelineStudyResultIdGet(pipelineStudyResultId: string, options?: RawAxiosRequestConfig) {
        return PipelineStudyResultsApiFp(this.configuration).pipelineStudyResultsPipelineStudyResultIdGet(pipelineStudyResultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PUT/update a pipeline run result by ID
     * @param {string} pipelineStudyResultId 
     * @param {PipelineStudyResult} [pipelineStudyResult] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineStudyResultsApi
     */
    public pipelineStudyResultsPipelineStudyResultIdPut(pipelineStudyResultId: string, pipelineStudyResult?: PipelineStudyResult, options?: RawAxiosRequestConfig) {
        return PipelineStudyResultsApiFp(this.configuration).pipelineStudyResultsPipelineStudyResultIdPut(pipelineStudyResultId, pipelineStudyResult, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary POST/create a pipeline run result
     * @param {PipelineStudyResult} [pipelineStudyResult] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineStudyResultsApi
     */
    public pipelineStudyResultsPost(pipelineStudyResult?: PipelineStudyResult, options?: RawAxiosRequestConfig) {
        return PipelineStudyResultsApiFp(this.configuration).pipelineStudyResultsPost(pipelineStudyResult, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PipelinesApi - axios parameter creator
 * @export
 */
export const PipelinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary GET a list of pipelines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pipelines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DELETE a pipeline by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pipelinesIdDelete', 'id', id)
            const localVarPath = `/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GET a pipeline by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pipelinesIdGet', 'id', id)
            const localVarPath = `/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PUT/update a pipeline by ID
         * @param {string} id 
         * @param {Pipeline} [pipeline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesIdPut: async (id: string, pipeline?: Pipeline, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pipelinesIdPut', 'id', id)
            const localVarPath = `/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipeline, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary POST/create a pipeline
         * @param {Pipeline} [pipeline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesPost: async (pipeline?: Pipeline, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pipelines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipeline, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelinesApi - functional programming interface
 * @export
 */
export const PipelinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PipelinesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary GET a list of pipelines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary DELETE a pipeline by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary GET a pipeline by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary PUT/update a pipeline by ID
         * @param {string} id 
         * @param {Pipeline} [pipeline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesIdPut(id: string, pipeline?: Pipeline, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesIdPut(id, pipeline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary POST/create a pipeline
         * @param {Pipeline} [pipeline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesPost(pipeline?: Pipeline, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesPost(pipeline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PipelinesApi - factory interface
 * @export
 */
export const PipelinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PipelinesApiFp(configuration)
    return {
        /**
         * 
         * @summary GET a list of pipelines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesGet(options?: RawAxiosRequestConfig): AxiosPromise<PipelineList> {
            return localVarFp.pipelinesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DELETE a pipeline by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pipelinesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GET a pipeline by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Pipeline> {
            return localVarFp.pipelinesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PUT/update a pipeline by ID
         * @param {string} id 
         * @param {Pipeline} [pipeline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesIdPut(id: string, pipeline?: Pipeline, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pipelinesIdPut(id, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary POST/create a pipeline
         * @param {Pipeline} [pipeline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesPost(pipeline?: Pipeline, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pipelinesPost(pipeline, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PipelinesApi - object-oriented interface
 * @export
 * @class PipelinesApi
 * @extends {BaseAPI}
 */
export class PipelinesApi extends BaseAPI {
    /**
     * 
     * @summary GET a list of pipelines
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesGet(options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DELETE a pipeline by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GET a pipeline by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PUT/update a pipeline by ID
     * @param {string} id 
     * @param {Pipeline} [pipeline] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesIdPut(id: string, pipeline?: Pipeline, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesIdPut(id, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary POST/create a pipeline
     * @param {Pipeline} [pipeline] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesPost(pipeline?: Pipeline, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesPost(pipeline, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PointsApi - axios parameter creator
 * @export
 */
export const PointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * list points in database
         * @summary Get Points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/points/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a point
         * @summary DELETE a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointsIdDelete', 'id', id)
            const localVarPath = `/points/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Information about a particular MRI coordinate
         * @summary GET a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointsIdGet', 'id', id)
            const localVarPath = `/points/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a particular MRI coordinate.
         * @summary PUT/update a point
         * @param {string} id 
         * @param {PointRequest} [pointRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdPut: async (id: string, pointRequest?: PointRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointsIdPut', 'id', id)
            const localVarPath = `/points/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pointRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * add a point to an analysis
         * @summary POST Points
         * @param {PointRequest} [pointRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsPost: async (pointRequest?: PointRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/points/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pointRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PointsApi - functional programming interface
 * @export
 */
export const PointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PointsApiAxiosParamCreator(configuration)
    return {
        /**
         * list points in database
         * @summary Get Points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PointsApi.pointsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete a point
         * @summary DELETE a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PointsApi.pointsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Information about a particular MRI coordinate
         * @summary GET a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PointsApi.pointsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a particular MRI coordinate.
         * @summary PUT/update a point
         * @param {string} id 
         * @param {PointRequest} [pointRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsIdPut(id: string, pointRequest?: PointRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsIdPut(id, pointRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PointsApi.pointsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * add a point to an analysis
         * @summary POST Points
         * @param {PointRequest} [pointRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsPost(pointRequest?: PointRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsPost(pointRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PointsApi.pointsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PointsApi - factory interface
 * @export
 */
export const PointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PointsApiFp(configuration)
    return {
        /**
         * list points in database
         * @summary Get Points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsGet(options?: RawAxiosRequestConfig): AxiosPromise<PointList> {
            return localVarFp.pointsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * delete a point
         * @summary DELETE a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pointsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Information about a particular MRI coordinate
         * @summary GET a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PointReturn> {
            return localVarFp.pointsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a particular MRI coordinate.
         * @summary PUT/update a point
         * @param {string} id 
         * @param {PointRequest} [pointRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdPut(id: string, pointRequest?: PointRequest, options?: RawAxiosRequestConfig): AxiosPromise<PointReturn> {
            return localVarFp.pointsIdPut(id, pointRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * add a point to an analysis
         * @summary POST Points
         * @param {PointRequest} [pointRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsPost(pointRequest?: PointRequest, options?: RawAxiosRequestConfig): AxiosPromise<PointReturn> {
            return localVarFp.pointsPost(pointRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PointsApi - object-oriented interface
 * @export
 * @class PointsApi
 * @extends {BaseAPI}
 */
export class PointsApi extends BaseAPI {
    /**
     * list points in database
     * @summary Get Points
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public pointsGet(options?: RawAxiosRequestConfig) {
        return PointsApiFp(this.configuration).pointsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a point
     * @summary DELETE a point
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public pointsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return PointsApiFp(this.configuration).pointsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Information about a particular MRI coordinate
     * @summary GET a point
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public pointsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return PointsApiFp(this.configuration).pointsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a particular MRI coordinate.
     * @summary PUT/update a point
     * @param {string} id 
     * @param {PointRequest} [pointRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public pointsIdPut(id: string, pointRequest?: PointRequest, options?: RawAxiosRequestConfig) {
        return PointsApiFp(this.configuration).pointsIdPut(id, pointRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * add a point to an analysis
     * @summary POST Points
     * @param {PointRequest} [pointRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public pointsPost(pointRequest?: PointRequest, options?: RawAxiosRequestConfig) {
        return PointsApiFp(this.configuration).pointsPost(pointRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StoreApi - axios parameter creator
 * @export
 */
export const StoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all analyses performed across studies.
         * @summary GET list of analyses
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesGet: async (search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, nested?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analyses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete an analysis
         * @summary DELETE an analysis
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('analysesIdDelete', 'id', id)
            const localVarPath = `/analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Information pertaining to a particular analysis within a study.
         * @summary GET an analysis
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdGet: async (id: string, nested?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('analysesIdGet', 'id', id)
            const localVarPath = `/analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing analysis.
         * @summary PUT/update an analysis
         * @param {string} id 
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdPut: async (id: string, analysisRequest?: AnalysisRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('analysesIdPut', 'id', id)
            const localVarPath = `/analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create an analysis
         * @summary POST/create an analysis
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesPost: async (analysisRequest?: AnalysisRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analyses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get annotation analyses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotation-analyses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationAnalysesIdGet', 'id', id)
            const localVarPath = `/annotation-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Your PUT endpoint
         * @param {string} id 
         * @param {NoteCollectionRequest} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesIdPut: async (id: string, noteCollectionRequest?: NoteCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationAnalysesIdPut', 'id', id)
            const localVarPath = `/annotation-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noteCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint does not allow for creation, only modification of existing annotation-analyses. If you wish to create an annotation-analysis, post to the annotations endpoint and/or add the analysis to the appropriate study in the studyset, and the annotation-analysis will be created automatically. 
         * @summary Your POST endpoint
         * @param {Array<NoteCollectionRequest>} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesPost: async (noteCollectionRequest?: Array<NoteCollectionRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotation-analyses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noteCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get annotations for an available studyset
         * @summary Your GET endpoint
         * @param {string} [studysetId] see all annotations connected to this studyset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsGet: async (studysetId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (studysetId !== undefined) {
                localVarQueryParameter['studyset_id'] = studysetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete annotation
         * @summary DELETE an annotation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsIdDelete', 'id', id)
            const localVarPath = `/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get an individual annotation
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [_export] return endpoint data in consumable/readable format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdGet: async (id: string, _export?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsIdGet', 'id', id)
            const localVarPath = `/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (_export !== undefined) {
                localVarQueryParameter['export'] = _export;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * edit an existing annotation
         * @summary Update an annotation
         * @param {string} id 
         * @param {AnnotationRequest} [annotationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdPut: async (id: string, annotationRequest?: AnnotationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsIdPut', 'id', id)
            const localVarPath = `/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an annotation
         * @summary Post Annotation
         * @param {AnnotationsPostSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {AnnotationRequest} [annotationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsPost: async (source?: AnnotationsPostSourceEnum, sourceId?: string, annotationRequest?: AnnotationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {Array<string>} [featureFilter] Filter studies by feature content. Format: \&quot;PipelineName[:version]:field_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:predictions.age_mean&gt;20\&quot; (specific version)   - \&quot;TestPipeline:groups.diagnosis&#x3D;ADHD\&quot; (latest version)  Field path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {Array<string>} [pipelineConfig] Filter studies by pipeline config content. Format: \&quot;PipelineName[:version]:config_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:settings.min_age&#x3D;20\&quot; (specific version)   - \&quot;TestPipeline:model.type&#x3D;linear\&quot; (latest version)  Config path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {string} [featureDisplay] display features from pipelines
         * @param {boolean} [featureFlatten] 
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [authors] search authors
         * @param {BaseStudiesGetLevelEnum} [level] select between studies with group results or meta results
         * @param {BaseStudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
         * @param {string} [publication] search for papers from a particular journal
         * @param {string} [pmid] search for particular pmid
         * @param {string} [doi] search for study with specific doi
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesGet: async (featureFilter?: Array<string>, pipelineConfig?: Array<string>, featureDisplay?: string, featureFlatten?: boolean, search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, authors?: string, level?: BaseStudiesGetLevelEnum, dataType?: BaseStudiesGetDataTypeEnum, publication?: string, pmid?: string, doi?: string, flat?: boolean, info?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/base-studies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (featureFilter) {
                localVarQueryParameter['feature_filter'] = featureFilter;
            }

            if (pipelineConfig) {
                localVarQueryParameter['pipeline_config'] = pipelineConfig;
            }

            if (featureDisplay !== undefined) {
                localVarQueryParameter['feature_display'] = featureDisplay;
            }

            if (featureFlatten !== undefined) {
                localVarQueryParameter['feature_flatten'] = featureFlatten;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (authors !== undefined) {
                localVarQueryParameter['authors'] = authors;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (dataType !== undefined) {
                localVarQueryParameter['data_type'] = dataType;
            }

            if (publication !== undefined) {
                localVarQueryParameter['publication'] = publication;
            }

            if (pmid !== undefined) {
                localVarQueryParameter['pmid'] = pmid;
            }

            if (doi !== undefined) {
                localVarQueryParameter['doi'] = doi;
            }

            if (flat !== undefined) {
                localVarQueryParameter['flat'] = flat;
            }

            if (info !== undefined) {
                localVarQueryParameter['info'] = info;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesIdGet: async (id: string, flat?: boolean, info?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('baseStudiesIdGet', 'id', id)
            const localVarPath = `/base-studies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flat !== undefined) {
                localVarQueryParameter['flat'] = flat;
            }

            if (info !== undefined) {
                localVarQueryParameter['info'] = info;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {BaseStudy} [baseStudy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesIdPut: async (id: string, baseStudy?: BaseStudy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('baseStudiesIdPut', 'id', id)
            const localVarPath = `/base-studies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseStudy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {BaseStudiesPostRequest} [baseStudiesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesPost: async (baseStudiesPostRequest?: BaseStudiesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/base-studies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseStudiesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all conditions
         * @summary GET Conditions
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsGet: async (search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conditions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a condition
         * @summary DELETE a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('conditionsIdDelete', 'id', id)
            const localVarPath = `/conditions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
         * @summary GET a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('conditionsIdGet', 'id', id)
            const localVarPath = `/conditions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a condition
         * @summary PUT/update a condition
         * @param {string} id 
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdPut: async (id: string, conditionRequest?: ConditionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('conditionsIdPut', 'id', id)
            const localVarPath = `/conditions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conditionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a condition
         * @summary POST/Create a condition
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsPost: async (conditionRequest?: ConditionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conditions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conditionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve and list images.
         * @summary GET a list of images
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [filename] search filename field
         * @param {string} [analysisName] search analysis_name field
         * @param {string} [valueType] search value_type field
         * @param {string} [space] search space field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesGet: async (search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, filename?: string, analysisName?: string, valueType?: string, space?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/images/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (analysisName !== undefined) {
                localVarQueryParameter['analysis_name'] = analysisName;
            }

            if (valueType !== undefined) {
                localVarQueryParameter['value_type'] = valueType;
            }

            if (space !== undefined) {
                localVarQueryParameter['space'] = space;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete an image
         * @summary DELETE an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesIdDelete', 'id', id)
            const localVarPath = `/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about a particular image from an analysis.
         * @summary GET an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesIdGet', 'id', id)
            const localVarPath = `/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific image.
         * @summary PUT/update an image
         * @param {string} id 
         * @param {ImageRequest} [imageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdPut: async (id: string, imageRequest?: ImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesIdPut', 'id', id)
            const localVarPath = `/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an image
         * @summary POST/create an image
         * @param {ImageRequest} [imageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesPost: async (imageRequest?: ImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/images/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list points in database
         * @summary Get Points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/points/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a point
         * @summary DELETE a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointsIdDelete', 'id', id)
            const localVarPath = `/points/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Information about a particular MRI coordinate
         * @summary GET a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointsIdGet', 'id', id)
            const localVarPath = `/points/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a particular MRI coordinate.
         * @summary PUT/update a point
         * @param {string} id 
         * @param {PointRequest} [pointRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdPut: async (id: string, pointRequest?: PointRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointsIdPut', 'id', id)
            const localVarPath = `/points/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pointRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * add a point to an analysis
         * @summary POST Points
         * @param {PointRequest} [pointRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsPost: async (pointRequest?: PointRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/points/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pointRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List studies
         * @summary GET a list of studies
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {any} [unique] whether to list clones with originals
         * @param {StudiesGetSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [authors] search authors
         * @param {string} [userId] user id you want to filter by
         * @param {StudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
         * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
         * @param {StudiesGetLevelEnum} [level] select between studies with group results or meta results
         * @param {string} [pmid] search for particular pmid
         * @param {string} [doi] search for study with specific doi
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesGet: async (search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: any, source?: StudiesGetSourceEnum, authors?: string, userId?: string, dataType?: StudiesGetDataTypeEnum, studysetOwner?: string, level?: StudiesGetLevelEnum, pmid?: string, doi?: string, flat?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/studies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }

            if (unique !== undefined) {
                for (const [key, value] of Object.entries(unique)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (authors !== undefined) {
                localVarQueryParameter['authors'] = authors;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (dataType !== undefined) {
                localVarQueryParameter['data_type'] = dataType;
            }

            if (studysetOwner !== undefined) {
                localVarQueryParameter['studyset_owner'] = studysetOwner;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (pmid !== undefined) {
                localVarQueryParameter['pmid'] = pmid;
            }

            if (doi !== undefined) {
                localVarQueryParameter['doi'] = doi;
            }

            if (flat !== undefined) {
                localVarQueryParameter['flat'] = flat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a study
         * @summary DELETE a study
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studiesIdDelete', 'id', id)
            const localVarPath = `/studies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a study.
         * @summary GET a study
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdGet: async (id: string, nested?: boolean, studysetOwner?: string, flat?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studiesIdGet', 'id', id)
            const localVarPath = `/studies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            if (studysetOwner !== undefined) {
                localVarQueryParameter['studyset_owner'] = studysetOwner;
            }

            if (flat !== undefined) {
                localVarQueryParameter['flat'] = flat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a study.
         * @summary PUT/update a study
         * @param {string} id 
         * @param {StudyRequest} [studyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdPut: async (id: string, studyRequest?: StudyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studiesIdPut', 'id', id)
            const localVarPath = `/studies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a study
         * @summary POST/create a study
         * @param {StudiesPostSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {StudyRequest} [studyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesPost: async (source?: StudiesPostSourceEnum, sourceId?: string, studyRequest?: StudyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/studies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a studyset
         * @summary DELETE a studyset
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studysetsIdDelete', 'id', id)
            const localVarPath = `/studysets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the information of a studyset with the matching studyset ID.
         * @summary GET a studyset
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {boolean} [gzip] return the content as gzipped content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdGet: async (id: string, nested?: boolean, gzip?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studysetsIdGet', 'id', id)
            const localVarPath = `/studysets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            if (gzip !== undefined) {
                localVarQueryParameter['gzip'] = gzip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a studyset.
         * @summary PUT/update a studyset
         * @param {string} id 
         * @param {StudysetRequest} [studysetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdPut: async (id: string, studysetRequest?: StudysetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studysetsIdPut', 'id', id)
            const localVarPath = `/studysets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studysetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a studyset.
         * @summary POST/create a studyset
         * @param {StudysetRequest} [studysetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsPost: async (studysetRequest?: StudysetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/studysets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studysetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoreApiAxiosParamCreator(configuration)
    return {
        /**
         * List all analyses performed across studies.
         * @summary GET list of analyses
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, nested?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesGet(search, sort, page, desc, pageSize, name, description, nested, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.analysesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete an analysis
         * @summary DELETE an analysis
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.analysesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Information pertaining to a particular analysis within a study.
         * @summary GET an analysis
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesIdGet(id: string, nested?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesIdGet(id, nested, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.analysesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing analysis.
         * @summary PUT/update an analysis
         * @param {string} id 
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesIdPut(id: string, analysisRequest?: AnalysisRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesIdPut(id, analysisRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.analysesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create an analysis
         * @summary POST/create an analysis
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesPost(analysisRequest?: AnalysisRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesPost(analysisRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.analysesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get annotation analyses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationAnalysesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteCollectionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationAnalysesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.annotationAnalysesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationAnalysesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteCollectionReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationAnalysesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.annotationAnalysesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Your PUT endpoint
         * @param {string} id 
         * @param {NoteCollectionRequest} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationAnalysesIdPut(id: string, noteCollectionRequest?: NoteCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoteCollectionReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationAnalysesIdPut(id, noteCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.annotationAnalysesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint does not allow for creation, only modification of existing annotation-analyses. If you wish to create an annotation-analysis, post to the annotations endpoint and/or add the analysis to the appropriate study in the studyset, and the annotation-analysis will be created automatically. 
         * @summary Your POST endpoint
         * @param {Array<NoteCollectionRequest>} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationAnalysesPost(noteCollectionRequest?: Array<NoteCollectionRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NoteCollectionReturn>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationAnalysesPost(noteCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.annotationAnalysesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get annotations for an available studyset
         * @summary Your GET endpoint
         * @param {string} [studysetId] see all annotations connected to this studyset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsGet(studysetId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsGet(studysetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.annotationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete annotation
         * @summary DELETE an annotation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.annotationsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get an individual annotation
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [_export] return endpoint data in consumable/readable format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsIdGet(id: string, _export?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsIdGet(id, _export, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.annotationsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * edit an existing annotation
         * @summary Update an annotation
         * @param {string} id 
         * @param {AnnotationRequest} [annotationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsIdPut(id: string, annotationRequest?: AnnotationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsIdPut(id, annotationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.annotationsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an annotation
         * @summary Post Annotation
         * @param {AnnotationsPostSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {AnnotationRequest} [annotationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsPost(source?: AnnotationsPostSourceEnum, sourceId?: string, annotationRequest?: AnnotationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsPost(source, sourceId, annotationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.annotationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {Array<string>} [featureFilter] Filter studies by feature content. Format: \&quot;PipelineName[:version]:field_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:predictions.age_mean&gt;20\&quot; (specific version)   - \&quot;TestPipeline:groups.diagnosis&#x3D;ADHD\&quot; (latest version)  Field path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {Array<string>} [pipelineConfig] Filter studies by pipeline config content. Format: \&quot;PipelineName[:version]:config_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:settings.min_age&#x3D;20\&quot; (specific version)   - \&quot;TestPipeline:model.type&#x3D;linear\&quot; (latest version)  Config path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {string} [featureDisplay] display features from pipelines
         * @param {boolean} [featureFlatten] 
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [authors] search authors
         * @param {BaseStudiesGetLevelEnum} [level] select between studies with group results or meta results
         * @param {BaseStudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
         * @param {string} [publication] search for papers from a particular journal
         * @param {string} [pmid] search for particular pmid
         * @param {string} [doi] search for study with specific doi
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async baseStudiesGet(featureFilter?: Array<string>, pipelineConfig?: Array<string>, featureDisplay?: string, featureFlatten?: boolean, search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, authors?: string, level?: BaseStudiesGetLevelEnum, dataType?: BaseStudiesGetDataTypeEnum, publication?: string, pmid?: string, doi?: string, flat?: boolean, info?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseStudyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.baseStudiesGet(featureFilter, pipelineConfig, featureDisplay, featureFlatten, search, sort, page, desc, pageSize, name, description, authors, level, dataType, publication, pmid, doi, flat, info, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.baseStudiesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async baseStudiesIdGet(id: string, flat?: boolean, info?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseStudyReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.baseStudiesIdGet(id, flat, info, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.baseStudiesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {BaseStudy} [baseStudy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async baseStudiesIdPut(id: string, baseStudy?: BaseStudy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseStudyReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.baseStudiesIdPut(id, baseStudy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.baseStudiesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {BaseStudiesPostRequest} [baseStudiesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async baseStudiesPost(baseStudiesPostRequest?: BaseStudiesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseStudiesPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.baseStudiesPost(baseStudiesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.baseStudiesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all conditions
         * @summary GET Conditions
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConditionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsGet(search, sort, page, desc, pageSize, name, description, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.conditionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete a condition
         * @summary DELETE a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.conditionsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
         * @summary GET a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConditionReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.conditionsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update a condition
         * @summary PUT/update a condition
         * @param {string} id 
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsIdPut(id: string, conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConditionReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsIdPut(id, conditionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.conditionsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a condition
         * @summary POST/Create a condition
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsPost(conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConditionReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsPost(conditionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.conditionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve and list images.
         * @summary GET a list of images
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [filename] search filename field
         * @param {string} [analysisName] search analysis_name field
         * @param {string} [valueType] search value_type field
         * @param {string} [space] search space field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, filename?: string, analysisName?: string, valueType?: string, space?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesGet(search, sort, page, desc, pageSize, filename, analysisName, valueType, space, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.imagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete an image
         * @summary DELETE an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.imagesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve information about a particular image from an analysis.
         * @summary GET an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.imagesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific image.
         * @summary PUT/update an image
         * @param {string} id 
         * @param {ImageRequest} [imageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesIdPut(id: string, imageRequest?: ImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesIdPut(id, imageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.imagesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an image
         * @summary POST/create an image
         * @param {ImageRequest} [imageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesPost(imageRequest?: ImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesPost(imageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.imagesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list points in database
         * @summary Get Points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.pointsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete a point
         * @summary DELETE a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.pointsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Information about a particular MRI coordinate
         * @summary GET a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.pointsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a particular MRI coordinate.
         * @summary PUT/update a point
         * @param {string} id 
         * @param {PointRequest} [pointRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsIdPut(id: string, pointRequest?: PointRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsIdPut(id, pointRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.pointsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * add a point to an analysis
         * @summary POST Points
         * @param {PointRequest} [pointRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsPost(pointRequest?: PointRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsPost(pointRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.pointsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List studies
         * @summary GET a list of studies
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {any} [unique] whether to list clones with originals
         * @param {StudiesGetSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [authors] search authors
         * @param {string} [userId] user id you want to filter by
         * @param {StudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
         * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
         * @param {StudiesGetLevelEnum} [level] select between studies with group results or meta results
         * @param {string} [pmid] search for particular pmid
         * @param {string} [doi] search for study with specific doi
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: any, source?: StudiesGetSourceEnum, authors?: string, userId?: string, dataType?: StudiesGetDataTypeEnum, studysetOwner?: string, level?: StudiesGetLevelEnum, pmid?: string, doi?: string, flat?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, source, authors, userId, dataType, studysetOwner, level, pmid, doi, flat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.studiesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete a study
         * @summary DELETE a study
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.studiesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a study.
         * @summary GET a study
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesIdGet(id: string, nested?: boolean, studysetOwner?: string, flat?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesIdGet(id, nested, studysetOwner, flat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.studiesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a study.
         * @summary PUT/update a study
         * @param {string} id 
         * @param {StudyRequest} [studyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesIdPut(id: string, studyRequest?: StudyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesIdPut(id, studyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.studiesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a study
         * @summary POST/create a study
         * @param {StudiesPostSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {StudyRequest} [studyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesPost(source?: StudiesPostSourceEnum, sourceId?: string, studyRequest?: StudyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesPost(source, sourceId, studyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.studiesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete a studyset
         * @summary DELETE a studyset
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studysetsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studysetsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.studysetsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the information of a studyset with the matching studyset ID.
         * @summary GET a studyset
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {boolean} [gzip] return the content as gzipped content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studysetsIdGet(id: string, nested?: boolean, gzip?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudysetReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studysetsIdGet(id, nested, gzip, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.studysetsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a studyset.
         * @summary PUT/update a studyset
         * @param {string} id 
         * @param {StudysetRequest} [studysetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studysetsIdPut(id: string, studysetRequest?: StudysetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudysetReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studysetsIdPut(id, studysetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.studysetsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a studyset.
         * @summary POST/create a studyset
         * @param {StudysetRequest} [studysetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studysetsPost(studysetRequest?: StudysetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudysetReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studysetsPost(studysetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.studysetsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoreApiFp(configuration)
    return {
        /**
         * List all analyses performed across studies.
         * @summary GET list of analyses
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, nested?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<AnalysisList> {
            return localVarFp.analysesGet(search, sort, page, desc, pageSize, name, description, nested, options).then((request) => request(axios, basePath));
        },
        /**
         * delete an analysis
         * @summary DELETE an analysis
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analysesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Information pertaining to a particular analysis within a study.
         * @summary GET an analysis
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdGet(id: string, nested?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<AnalysisReturn> {
            return localVarFp.analysesIdGet(id, nested, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing analysis.
         * @summary PUT/update an analysis
         * @param {string} id 
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdPut(id: string, analysisRequest?: AnalysisRequest, options?: RawAxiosRequestConfig): AxiosPromise<AnalysisReturn> {
            return localVarFp.analysesIdPut(id, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * create an analysis
         * @summary POST/create an analysis
         * @param {AnalysisRequest} [analysisRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesPost(analysisRequest?: AnalysisRequest, options?: RawAxiosRequestConfig): AxiosPromise<AnalysisReturn> {
            return localVarFp.analysesPost(analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get annotation analyses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesGet(options?: RawAxiosRequestConfig): AxiosPromise<NoteCollectionList> {
            return localVarFp.annotationAnalysesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<NoteCollectionReturn> {
            return localVarFp.annotationAnalysesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Your PUT endpoint
         * @param {string} id 
         * @param {NoteCollectionRequest} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesIdPut(id: string, noteCollectionRequest?: NoteCollectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<NoteCollectionReturn> {
            return localVarFp.annotationAnalysesIdPut(id, noteCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint does not allow for creation, only modification of existing annotation-analyses. If you wish to create an annotation-analysis, post to the annotations endpoint and/or add the analysis to the appropriate study in the studyset, and the annotation-analysis will be created automatically. 
         * @summary Your POST endpoint
         * @param {Array<NoteCollectionRequest>} [noteCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationAnalysesPost(noteCollectionRequest?: Array<NoteCollectionRequest>, options?: RawAxiosRequestConfig): AxiosPromise<Array<NoteCollectionReturn>> {
            return localVarFp.annotationAnalysesPost(noteCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * get annotations for an available studyset
         * @summary Your GET endpoint
         * @param {string} [studysetId] see all annotations connected to this studyset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsGet(studysetId?: string, options?: RawAxiosRequestConfig): AxiosPromise<AnnotationList> {
            return localVarFp.annotationsGet(studysetId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete annotation
         * @summary DELETE an annotation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.annotationsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get an individual annotation
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [_export] return endpoint data in consumable/readable format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdGet(id: string, _export?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<AnnotationReturn> {
            return localVarFp.annotationsIdGet(id, _export, options).then((request) => request(axios, basePath));
        },
        /**
         * edit an existing annotation
         * @summary Update an annotation
         * @param {string} id 
         * @param {AnnotationRequest} [annotationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdPut(id: string, annotationRequest?: AnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<AnnotationReturn> {
            return localVarFp.annotationsIdPut(id, annotationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an annotation
         * @summary Post Annotation
         * @param {AnnotationsPostSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {AnnotationRequest} [annotationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsPost(source?: AnnotationsPostSourceEnum, sourceId?: string, annotationRequest?: AnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<AnnotationReturn> {
            return localVarFp.annotationsPost(source, sourceId, annotationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {Array<string>} [featureFilter] Filter studies by feature content. Format: \&quot;PipelineName[:version]:field_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:predictions.age_mean&gt;20\&quot; (specific version)   - \&quot;TestPipeline:groups.diagnosis&#x3D;ADHD\&quot; (latest version)  Field path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {Array<string>} [pipelineConfig] Filter studies by pipeline config content. Format: \&quot;PipelineName[:version]:config_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:settings.min_age&#x3D;20\&quot; (specific version)   - \&quot;TestPipeline:model.type&#x3D;linear\&quot; (latest version)  Config path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {string} [featureDisplay] display features from pipelines
         * @param {boolean} [featureFlatten] 
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [authors] search authors
         * @param {BaseStudiesGetLevelEnum} [level] select between studies with group results or meta results
         * @param {BaseStudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
         * @param {string} [publication] search for papers from a particular journal
         * @param {string} [pmid] search for particular pmid
         * @param {string} [doi] search for study with specific doi
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesGet(featureFilter?: Array<string>, pipelineConfig?: Array<string>, featureDisplay?: string, featureFlatten?: boolean, search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, authors?: string, level?: BaseStudiesGetLevelEnum, dataType?: BaseStudiesGetDataTypeEnum, publication?: string, pmid?: string, doi?: string, flat?: boolean, info?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<BaseStudyList> {
            return localVarFp.baseStudiesGet(featureFilter, pipelineConfig, featureDisplay, featureFlatten, search, sort, page, desc, pageSize, name, description, authors, level, dataType, publication, pmid, doi, flat, info, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesIdGet(id: string, flat?: boolean, info?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<BaseStudyReturn> {
            return localVarFp.baseStudiesIdGet(id, flat, info, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {BaseStudy} [baseStudy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesIdPut(id: string, baseStudy?: BaseStudy, options?: RawAxiosRequestConfig): AxiosPromise<BaseStudyReturn> {
            return localVarFp.baseStudiesIdPut(id, baseStudy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {BaseStudiesPostRequest} [baseStudiesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesPost(baseStudiesPostRequest?: BaseStudiesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseStudiesPost200Response> {
            return localVarFp.baseStudiesPost(baseStudiesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all conditions
         * @summary GET Conditions
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, options?: RawAxiosRequestConfig): AxiosPromise<ConditionList> {
            return localVarFp.conditionsGet(search, sort, page, desc, pageSize, name, description, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a condition
         * @summary DELETE a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.conditionsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
         * @summary GET a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ConditionReturn> {
            return localVarFp.conditionsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * update a condition
         * @summary PUT/update a condition
         * @param {string} id 
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdPut(id: string, conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConditionReturn> {
            return localVarFp.conditionsIdPut(id, conditionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a condition
         * @summary POST/Create a condition
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsPost(conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConditionReturn> {
            return localVarFp.conditionsPost(conditionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve and list images.
         * @summary GET a list of images
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [filename] search filename field
         * @param {string} [analysisName] search analysis_name field
         * @param {string} [valueType] search value_type field
         * @param {string} [space] search space field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, filename?: string, analysisName?: string, valueType?: string, space?: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageList> {
            return localVarFp.imagesGet(search, sort, page, desc, pageSize, filename, analysisName, valueType, space, options).then((request) => request(axios, basePath));
        },
        /**
         * delete an image
         * @summary DELETE an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.imagesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information about a particular image from an analysis.
         * @summary GET an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageReturn> {
            return localVarFp.imagesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific image.
         * @summary PUT/update an image
         * @param {string} id 
         * @param {ImageRequest} [imageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdPut(id: string, imageRequest?: ImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageReturn> {
            return localVarFp.imagesIdPut(id, imageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an image
         * @summary POST/create an image
         * @param {ImageRequest} [imageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesPost(imageRequest?: ImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageReturn> {
            return localVarFp.imagesPost(imageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * list points in database
         * @summary Get Points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsGet(options?: RawAxiosRequestConfig): AxiosPromise<PointList> {
            return localVarFp.pointsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * delete a point
         * @summary DELETE a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pointsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Information about a particular MRI coordinate
         * @summary GET a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PointReturn> {
            return localVarFp.pointsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a particular MRI coordinate.
         * @summary PUT/update a point
         * @param {string} id 
         * @param {PointRequest} [pointRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdPut(id: string, pointRequest?: PointRequest, options?: RawAxiosRequestConfig): AxiosPromise<PointReturn> {
            return localVarFp.pointsIdPut(id, pointRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * add a point to an analysis
         * @summary POST Points
         * @param {PointRequest} [pointRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsPost(pointRequest?: PointRequest, options?: RawAxiosRequestConfig): AxiosPromise<PointReturn> {
            return localVarFp.pointsPost(pointRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List studies
         * @summary GET a list of studies
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {any} [unique] whether to list clones with originals
         * @param {StudiesGetSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [authors] search authors
         * @param {string} [userId] user id you want to filter by
         * @param {StudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
         * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
         * @param {StudiesGetLevelEnum} [level] select between studies with group results or meta results
         * @param {string} [pmid] search for particular pmid
         * @param {string} [doi] search for study with specific doi
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: any, source?: StudiesGetSourceEnum, authors?: string, userId?: string, dataType?: StudiesGetDataTypeEnum, studysetOwner?: string, level?: StudiesGetLevelEnum, pmid?: string, doi?: string, flat?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<StudyList> {
            return localVarFp.studiesGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, source, authors, userId, dataType, studysetOwner, level, pmid, doi, flat, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a study
         * @summary DELETE a study
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.studiesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a study.
         * @summary GET a study
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdGet(id: string, nested?: boolean, studysetOwner?: string, flat?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<StudyReturn> {
            return localVarFp.studiesIdGet(id, nested, studysetOwner, flat, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a study.
         * @summary PUT/update a study
         * @param {string} id 
         * @param {StudyRequest} [studyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdPut(id: string, studyRequest?: StudyRequest, options?: RawAxiosRequestConfig): AxiosPromise<StudyReturn> {
            return localVarFp.studiesIdPut(id, studyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a study
         * @summary POST/create a study
         * @param {StudiesPostSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {StudyRequest} [studyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesPost(source?: StudiesPostSourceEnum, sourceId?: string, studyRequest?: StudyRequest, options?: RawAxiosRequestConfig): AxiosPromise<StudyReturn> {
            return localVarFp.studiesPost(source, sourceId, studyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a studyset
         * @summary DELETE a studyset
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.studysetsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the information of a studyset with the matching studyset ID.
         * @summary GET a studyset
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {boolean} [gzip] return the content as gzipped content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdGet(id: string, nested?: boolean, gzip?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<StudysetReturn> {
            return localVarFp.studysetsIdGet(id, nested, gzip, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a studyset.
         * @summary PUT/update a studyset
         * @param {string} id 
         * @param {StudysetRequest} [studysetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdPut(id: string, studysetRequest?: StudysetRequest, options?: RawAxiosRequestConfig): AxiosPromise<StudysetReturn> {
            return localVarFp.studysetsIdPut(id, studysetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a studyset.
         * @summary POST/create a studyset
         * @param {StudysetRequest} [studysetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsPost(studysetRequest?: StudysetRequest, options?: RawAxiosRequestConfig): AxiosPromise<StudysetReturn> {
            return localVarFp.studysetsPost(studysetRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
    /**
     * List all analyses performed across studies.
     * @summary GET list of analyses
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public analysesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, nested?: boolean, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).analysesGet(search, sort, page, desc, pageSize, name, description, nested, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete an analysis
     * @summary DELETE an analysis
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public analysesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).analysesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Information pertaining to a particular analysis within a study.
     * @summary GET an analysis
     * @param {string} id 
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public analysesIdGet(id: string, nested?: boolean, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).analysesIdGet(id, nested, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing analysis.
     * @summary PUT/update an analysis
     * @param {string} id 
     * @param {AnalysisRequest} [analysisRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public analysesIdPut(id: string, analysisRequest?: AnalysisRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).analysesIdPut(id, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create an analysis
     * @summary POST/create an analysis
     * @param {AnalysisRequest} [analysisRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public analysesPost(analysisRequest?: AnalysisRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).analysesPost(analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get annotation analyses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public annotationAnalysesGet(options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).annotationAnalysesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Your GET endpoint
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public annotationAnalysesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).annotationAnalysesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Your PUT endpoint
     * @param {string} id 
     * @param {NoteCollectionRequest} [noteCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public annotationAnalysesIdPut(id: string, noteCollectionRequest?: NoteCollectionRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).annotationAnalysesIdPut(id, noteCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint does not allow for creation, only modification of existing annotation-analyses. If you wish to create an annotation-analysis, post to the annotations endpoint and/or add the analysis to the appropriate study in the studyset, and the annotation-analysis will be created automatically. 
     * @summary Your POST endpoint
     * @param {Array<NoteCollectionRequest>} [noteCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public annotationAnalysesPost(noteCollectionRequest?: Array<NoteCollectionRequest>, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).annotationAnalysesPost(noteCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get annotations for an available studyset
     * @summary Your GET endpoint
     * @param {string} [studysetId] see all annotations connected to this studyset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public annotationsGet(studysetId?: string, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).annotationsGet(studysetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete annotation
     * @summary DELETE an annotation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public annotationsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).annotationsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get an individual annotation
     * @summary Your GET endpoint
     * @param {string} id 
     * @param {boolean} [_export] return endpoint data in consumable/readable format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public annotationsIdGet(id: string, _export?: boolean, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).annotationsIdGet(id, _export, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * edit an existing annotation
     * @summary Update an annotation
     * @param {string} id 
     * @param {AnnotationRequest} [annotationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public annotationsIdPut(id: string, annotationRequest?: AnnotationRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).annotationsIdPut(id, annotationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an annotation
     * @summary Post Annotation
     * @param {AnnotationsPostSourceEnum} [source] the source of the resource you would like to filter/copy from
     * @param {string} [sourceId] id of the resource you are either filtering/copying on
     * @param {AnnotationRequest} [annotationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public annotationsPost(source?: AnnotationsPostSourceEnum, sourceId?: string, annotationRequest?: AnnotationRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).annotationsPost(source, sourceId, annotationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {Array<string>} [featureFilter] Filter studies by feature content. Format: \&quot;PipelineName[:version]:field_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:predictions.age_mean&gt;20\&quot; (specific version)   - \&quot;TestPipeline:groups.diagnosis&#x3D;ADHD\&quot; (latest version)  Field path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
     * @param {Array<string>} [pipelineConfig] Filter studies by pipeline config content. Format: \&quot;PipelineName[:version]:config_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:settings.min_age&#x3D;20\&quot; (specific version)   - \&quot;TestPipeline:model.type&#x3D;linear\&quot; (latest version)  Config path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
     * @param {string} [featureDisplay] display features from pipelines
     * @param {boolean} [featureFlatten] 
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {string} [authors] search authors
     * @param {BaseStudiesGetLevelEnum} [level] select between studies with group results or meta results
     * @param {BaseStudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
     * @param {string} [publication] search for papers from a particular journal
     * @param {string} [pmid] search for particular pmid
     * @param {string} [doi] search for study with specific doi
     * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
     * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public baseStudiesGet(featureFilter?: Array<string>, pipelineConfig?: Array<string>, featureDisplay?: string, featureFlatten?: boolean, search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, authors?: string, level?: BaseStudiesGetLevelEnum, dataType?: BaseStudiesGetDataTypeEnum, publication?: string, pmid?: string, doi?: string, flat?: boolean, info?: boolean, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).baseStudiesGet(featureFilter, pipelineConfig, featureDisplay, featureFlatten, search, sort, page, desc, pageSize, name, description, authors, level, dataType, publication, pmid, doi, flat, info, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Your GET endpoint
     * @param {string} id 
     * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
     * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public baseStudiesIdGet(id: string, flat?: boolean, info?: boolean, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).baseStudiesIdGet(id, flat, info, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} id 
     * @param {BaseStudy} [baseStudy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public baseStudiesIdPut(id: string, baseStudy?: BaseStudy, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).baseStudiesIdPut(id, baseStudy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {BaseStudiesPostRequest} [baseStudiesPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public baseStudiesPost(baseStudiesPostRequest?: BaseStudiesPostRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).baseStudiesPost(baseStudiesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all conditions
     * @summary GET Conditions
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public conditionsGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).conditionsGet(search, sort, page, desc, pageSize, name, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a condition
     * @summary DELETE a condition
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public conditionsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).conditionsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
     * @summary GET a condition
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public conditionsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).conditionsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a condition
     * @summary PUT/update a condition
     * @param {string} id 
     * @param {ConditionRequest} [conditionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public conditionsIdPut(id: string, conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).conditionsIdPut(id, conditionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a condition
     * @summary POST/Create a condition
     * @param {ConditionRequest} [conditionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public conditionsPost(conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).conditionsPost(conditionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve and list images.
     * @summary GET a list of images
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {string} [filename] search filename field
     * @param {string} [analysisName] search analysis_name field
     * @param {string} [valueType] search value_type field
     * @param {string} [space] search space field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public imagesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, filename?: string, analysisName?: string, valueType?: string, space?: string, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).imagesGet(search, sort, page, desc, pageSize, filename, analysisName, valueType, space, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete an image
     * @summary DELETE an image
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public imagesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).imagesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information about a particular image from an analysis.
     * @summary GET an image
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public imagesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).imagesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific image.
     * @summary PUT/update an image
     * @param {string} id 
     * @param {ImageRequest} [imageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public imagesIdPut(id: string, imageRequest?: ImageRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).imagesIdPut(id, imageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an image
     * @summary POST/create an image
     * @param {ImageRequest} [imageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public imagesPost(imageRequest?: ImageRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).imagesPost(imageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list points in database
     * @summary Get Points
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public pointsGet(options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).pointsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a point
     * @summary DELETE a point
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public pointsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).pointsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Information about a particular MRI coordinate
     * @summary GET a point
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public pointsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).pointsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a particular MRI coordinate.
     * @summary PUT/update a point
     * @param {string} id 
     * @param {PointRequest} [pointRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public pointsIdPut(id: string, pointRequest?: PointRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).pointsIdPut(id, pointRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * add a point to an analysis
     * @summary POST Points
     * @param {PointRequest} [pointRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public pointsPost(pointRequest?: PointRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).pointsPost(pointRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List studies
     * @summary GET a list of studies
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {string} [sourceId] id of the resource you are either filtering/copying on
     * @param {any} [unique] whether to list clones with originals
     * @param {StudiesGetSourceEnum} [source] the source of the resource you would like to filter/copy from
     * @param {string} [authors] search authors
     * @param {string} [userId] user id you want to filter by
     * @param {StudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
     * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
     * @param {StudiesGetLevelEnum} [level] select between studies with group results or meta results
     * @param {string} [pmid] search for particular pmid
     * @param {string} [doi] search for study with specific doi
     * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public studiesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: any, source?: StudiesGetSourceEnum, authors?: string, userId?: string, dataType?: StudiesGetDataTypeEnum, studysetOwner?: string, level?: StudiesGetLevelEnum, pmid?: string, doi?: string, flat?: boolean, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).studiesGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, source, authors, userId, dataType, studysetOwner, level, pmid, doi, flat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a study
     * @summary DELETE a study
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public studiesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).studiesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a study.
     * @summary GET a study
     * @param {string} id 
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
     * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public studiesIdGet(id: string, nested?: boolean, studysetOwner?: string, flat?: boolean, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).studiesIdGet(id, nested, studysetOwner, flat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a study.
     * @summary PUT/update a study
     * @param {string} id 
     * @param {StudyRequest} [studyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public studiesIdPut(id: string, studyRequest?: StudyRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).studiesIdPut(id, studyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a study
     * @summary POST/create a study
     * @param {StudiesPostSourceEnum} [source] the source of the resource you would like to filter/copy from
     * @param {string} [sourceId] id of the resource you are either filtering/copying on
     * @param {StudyRequest} [studyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public studiesPost(source?: StudiesPostSourceEnum, sourceId?: string, studyRequest?: StudyRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).studiesPost(source, sourceId, studyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a studyset
     * @summary DELETE a studyset
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public studysetsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).studysetsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the information of a studyset with the matching studyset ID.
     * @summary GET a studyset
     * @param {string} id 
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {boolean} [gzip] return the content as gzipped content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public studysetsIdGet(id: string, nested?: boolean, gzip?: boolean, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).studysetsIdGet(id, nested, gzip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a studyset.
     * @summary PUT/update a studyset
     * @param {string} id 
     * @param {StudysetRequest} [studysetRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public studysetsIdPut(id: string, studysetRequest?: StudysetRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).studysetsIdPut(id, studysetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a studyset.
     * @summary POST/create a studyset
     * @param {StudysetRequest} [studysetRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public studysetsPost(studysetRequest?: StudysetRequest, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).studysetsPost(studysetRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AnnotationsPostSourceEnum = {
    Neurostore: 'neurostore',
    Neurovault: 'neurovault',
    Pubmed: 'pubmed',
    Neurosynth: 'neurosynth',
    Neuroquery: 'neuroquery',
    Pubget: 'pubget'
} as const;
export type AnnotationsPostSourceEnum = typeof AnnotationsPostSourceEnum[keyof typeof AnnotationsPostSourceEnum];
/**
 * @export
 */
export const BaseStudiesGetLevelEnum = {
    Group: 'group',
    Meta: 'meta'
} as const;
export type BaseStudiesGetLevelEnum = typeof BaseStudiesGetLevelEnum[keyof typeof BaseStudiesGetLevelEnum];
/**
 * @export
 */
export const BaseStudiesGetDataTypeEnum = {
    Coordinate: 'coordinate',
    Image: 'image',
    Both: 'both'
} as const;
export type BaseStudiesGetDataTypeEnum = typeof BaseStudiesGetDataTypeEnum[keyof typeof BaseStudiesGetDataTypeEnum];
/**
 * @export
 */
export const StudiesGetSourceEnum = {
    Neurostore: 'neurostore',
    Neurovault: 'neurovault',
    Pubmed: 'pubmed',
    Neurosynth: 'neurosynth',
    Neuroquery: 'neuroquery',
    Pubget: 'pubget'
} as const;
export type StudiesGetSourceEnum = typeof StudiesGetSourceEnum[keyof typeof StudiesGetSourceEnum];
/**
 * @export
 */
export const StudiesGetDataTypeEnum = {
    Coordinate: 'coordinate',
    Image: 'image',
    Both: 'both'
} as const;
export type StudiesGetDataTypeEnum = typeof StudiesGetDataTypeEnum[keyof typeof StudiesGetDataTypeEnum];
/**
 * @export
 */
export const StudiesGetLevelEnum = {
    Group: 'group',
    Meta: 'meta'
} as const;
export type StudiesGetLevelEnum = typeof StudiesGetLevelEnum[keyof typeof StudiesGetLevelEnum];
/**
 * @export
 */
export const StudiesPostSourceEnum = {
    Neurostore: 'neurostore',
    Neurovault: 'neurovault',
    Pubmed: 'pubmed',
    Neurosynth: 'neurosynth',
    Neuroquery: 'neuroquery',
    Pubget: 'pubget'
} as const;
export type StudiesPostSourceEnum = typeof StudiesPostSourceEnum[keyof typeof StudiesPostSourceEnum];


/**
 * StudiesApi - axios parameter creator
 * @export
 */
export const StudiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 
         * @param {Array<string>} [featureFilter] Filter studies by feature content. Format: \&quot;PipelineName[:version]:field_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:predictions.age_mean&gt;20\&quot; (specific version)   - \&quot;TestPipeline:groups.diagnosis&#x3D;ADHD\&quot; (latest version)  Field path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {Array<string>} [pipelineConfig] Filter studies by pipeline config content. Format: \&quot;PipelineName[:version]:config_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:settings.min_age&#x3D;20\&quot; (specific version)   - \&quot;TestPipeline:model.type&#x3D;linear\&quot; (latest version)  Config path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {string} [featureDisplay] display features from pipelines
         * @param {boolean} [featureFlatten] 
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [authors] search authors
         * @param {BaseStudiesGetLevelEnum} [level] select between studies with group results or meta results
         * @param {BaseStudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
         * @param {string} [publication] search for papers from a particular journal
         * @param {string} [pmid] search for particular pmid
         * @param {string} [doi] search for study with specific doi
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesGet: async (featureFilter?: Array<string>, pipelineConfig?: Array<string>, featureDisplay?: string, featureFlatten?: boolean, search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, authors?: string, level?: BaseStudiesGetLevelEnum, dataType?: BaseStudiesGetDataTypeEnum, publication?: string, pmid?: string, doi?: string, flat?: boolean, info?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/base-studies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (featureFilter) {
                localVarQueryParameter['feature_filter'] = featureFilter;
            }

            if (pipelineConfig) {
                localVarQueryParameter['pipeline_config'] = pipelineConfig;
            }

            if (featureDisplay !== undefined) {
                localVarQueryParameter['feature_display'] = featureDisplay;
            }

            if (featureFlatten !== undefined) {
                localVarQueryParameter['feature_flatten'] = featureFlatten;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (authors !== undefined) {
                localVarQueryParameter['authors'] = authors;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (dataType !== undefined) {
                localVarQueryParameter['data_type'] = dataType;
            }

            if (publication !== undefined) {
                localVarQueryParameter['publication'] = publication;
            }

            if (pmid !== undefined) {
                localVarQueryParameter['pmid'] = pmid;
            }

            if (doi !== undefined) {
                localVarQueryParameter['doi'] = doi;
            }

            if (flat !== undefined) {
                localVarQueryParameter['flat'] = flat;
            }

            if (info !== undefined) {
                localVarQueryParameter['info'] = info;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesIdGet: async (id: string, flat?: boolean, info?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('baseStudiesIdGet', 'id', id)
            const localVarPath = `/base-studies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flat !== undefined) {
                localVarQueryParameter['flat'] = flat;
            }

            if (info !== undefined) {
                localVarQueryParameter['info'] = info;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {BaseStudy} [baseStudy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesIdPut: async (id: string, baseStudy?: BaseStudy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('baseStudiesIdPut', 'id', id)
            const localVarPath = `/base-studies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseStudy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {BaseStudiesPostRequest} [baseStudiesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesPost: async (baseStudiesPostRequest?: BaseStudiesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/base-studies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseStudiesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List studies
         * @summary GET a list of studies
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {any} [unique] whether to list clones with originals
         * @param {StudiesGetSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [authors] search authors
         * @param {string} [userId] user id you want to filter by
         * @param {StudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
         * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
         * @param {StudiesGetLevelEnum} [level] select between studies with group results or meta results
         * @param {string} [pmid] search for particular pmid
         * @param {string} [doi] search for study with specific doi
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesGet: async (search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: any, source?: StudiesGetSourceEnum, authors?: string, userId?: string, dataType?: StudiesGetDataTypeEnum, studysetOwner?: string, level?: StudiesGetLevelEnum, pmid?: string, doi?: string, flat?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/studies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }

            if (unique !== undefined) {
                for (const [key, value] of Object.entries(unique)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (authors !== undefined) {
                localVarQueryParameter['authors'] = authors;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (dataType !== undefined) {
                localVarQueryParameter['data_type'] = dataType;
            }

            if (studysetOwner !== undefined) {
                localVarQueryParameter['studyset_owner'] = studysetOwner;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (pmid !== undefined) {
                localVarQueryParameter['pmid'] = pmid;
            }

            if (doi !== undefined) {
                localVarQueryParameter['doi'] = doi;
            }

            if (flat !== undefined) {
                localVarQueryParameter['flat'] = flat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a study
         * @summary DELETE a study
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studiesIdDelete', 'id', id)
            const localVarPath = `/studies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a study.
         * @summary GET a study
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdGet: async (id: string, nested?: boolean, studysetOwner?: string, flat?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studiesIdGet', 'id', id)
            const localVarPath = `/studies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            if (studysetOwner !== undefined) {
                localVarQueryParameter['studyset_owner'] = studysetOwner;
            }

            if (flat !== undefined) {
                localVarQueryParameter['flat'] = flat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a study.
         * @summary PUT/update a study
         * @param {string} id 
         * @param {StudyRequest} [studyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdPut: async (id: string, studyRequest?: StudyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studiesIdPut', 'id', id)
            const localVarPath = `/studies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a study
         * @summary POST/create a study
         * @param {StudiesPostSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {StudyRequest} [studyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesPost: async (source?: StudiesPostSourceEnum, sourceId?: string, studyRequest?: StudyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/studies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudiesApi - functional programming interface
 * @export
 */
export const StudiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {Array<string>} [featureFilter] Filter studies by feature content. Format: \&quot;PipelineName[:version]:field_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:predictions.age_mean&gt;20\&quot; (specific version)   - \&quot;TestPipeline:groups.diagnosis&#x3D;ADHD\&quot; (latest version)  Field path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {Array<string>} [pipelineConfig] Filter studies by pipeline config content. Format: \&quot;PipelineName[:version]:config_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:settings.min_age&#x3D;20\&quot; (specific version)   - \&quot;TestPipeline:model.type&#x3D;linear\&quot; (latest version)  Config path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {string} [featureDisplay] display features from pipelines
         * @param {boolean} [featureFlatten] 
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [authors] search authors
         * @param {BaseStudiesGetLevelEnum} [level] select between studies with group results or meta results
         * @param {BaseStudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
         * @param {string} [publication] search for papers from a particular journal
         * @param {string} [pmid] search for particular pmid
         * @param {string} [doi] search for study with specific doi
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async baseStudiesGet(featureFilter?: Array<string>, pipelineConfig?: Array<string>, featureDisplay?: string, featureFlatten?: boolean, search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, authors?: string, level?: BaseStudiesGetLevelEnum, dataType?: BaseStudiesGetDataTypeEnum, publication?: string, pmid?: string, doi?: string, flat?: boolean, info?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseStudyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.baseStudiesGet(featureFilter, pipelineConfig, featureDisplay, featureFlatten, search, sort, page, desc, pageSize, name, description, authors, level, dataType, publication, pmid, doi, flat, info, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.baseStudiesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async baseStudiesIdGet(id: string, flat?: boolean, info?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseStudyReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.baseStudiesIdGet(id, flat, info, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.baseStudiesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {BaseStudy} [baseStudy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async baseStudiesIdPut(id: string, baseStudy?: BaseStudy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseStudyReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.baseStudiesIdPut(id, baseStudy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.baseStudiesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {BaseStudiesPostRequest} [baseStudiesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async baseStudiesPost(baseStudiesPostRequest?: BaseStudiesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseStudiesPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.baseStudiesPost(baseStudiesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.baseStudiesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List studies
         * @summary GET a list of studies
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {any} [unique] whether to list clones with originals
         * @param {StudiesGetSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [authors] search authors
         * @param {string} [userId] user id you want to filter by
         * @param {StudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
         * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
         * @param {StudiesGetLevelEnum} [level] select between studies with group results or meta results
         * @param {string} [pmid] search for particular pmid
         * @param {string} [doi] search for study with specific doi
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: any, source?: StudiesGetSourceEnum, authors?: string, userId?: string, dataType?: StudiesGetDataTypeEnum, studysetOwner?: string, level?: StudiesGetLevelEnum, pmid?: string, doi?: string, flat?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, source, authors, userId, dataType, studysetOwner, level, pmid, doi, flat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.studiesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete a study
         * @summary DELETE a study
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.studiesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a study.
         * @summary GET a study
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesIdGet(id: string, nested?: boolean, studysetOwner?: string, flat?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesIdGet(id, nested, studysetOwner, flat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.studiesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a study.
         * @summary PUT/update a study
         * @param {string} id 
         * @param {StudyRequest} [studyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesIdPut(id: string, studyRequest?: StudyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesIdPut(id, studyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.studiesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a study
         * @summary POST/create a study
         * @param {StudiesPostSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {StudyRequest} [studyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesPost(source?: StudiesPostSourceEnum, sourceId?: string, studyRequest?: StudyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesPost(source, sourceId, studyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.studiesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StudiesApi - factory interface
 * @export
 */
export const StudiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudiesApiFp(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {Array<string>} [featureFilter] Filter studies by feature content. Format: \&quot;PipelineName[:version]:field_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:predictions.age_mean&gt;20\&quot; (specific version)   - \&quot;TestPipeline:groups.diagnosis&#x3D;ADHD\&quot; (latest version)  Field path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {Array<string>} [pipelineConfig] Filter studies by pipeline config content. Format: \&quot;PipelineName[:version]:config_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:settings.min_age&#x3D;20\&quot; (specific version)   - \&quot;TestPipeline:model.type&#x3D;linear\&quot; (latest version)  Config path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
         * @param {string} [featureDisplay] display features from pipelines
         * @param {boolean} [featureFlatten] 
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [authors] search authors
         * @param {BaseStudiesGetLevelEnum} [level] select between studies with group results or meta results
         * @param {BaseStudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
         * @param {string} [publication] search for papers from a particular journal
         * @param {string} [pmid] search for particular pmid
         * @param {string} [doi] search for study with specific doi
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesGet(featureFilter?: Array<string>, pipelineConfig?: Array<string>, featureDisplay?: string, featureFlatten?: boolean, search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, authors?: string, level?: BaseStudiesGetLevelEnum, dataType?: BaseStudiesGetDataTypeEnum, publication?: string, pmid?: string, doi?: string, flat?: boolean, info?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<BaseStudyList> {
            return localVarFp.baseStudiesGet(featureFilter, pipelineConfig, featureDisplay, featureFlatten, search, sort, page, desc, pageSize, name, description, authors, level, dataType, publication, pmid, doi, flat, info, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesIdGet(id: string, flat?: boolean, info?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<BaseStudyReturn> {
            return localVarFp.baseStudiesIdGet(id, flat, info, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} id 
         * @param {BaseStudy} [baseStudy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesIdPut(id: string, baseStudy?: BaseStudy, options?: RawAxiosRequestConfig): AxiosPromise<BaseStudyReturn> {
            return localVarFp.baseStudiesIdPut(id, baseStudy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {BaseStudiesPostRequest} [baseStudiesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        baseStudiesPost(baseStudiesPostRequest?: BaseStudiesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseStudiesPost200Response> {
            return localVarFp.baseStudiesPost(baseStudiesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List studies
         * @summary GET a list of studies
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {any} [unique] whether to list clones with originals
         * @param {StudiesGetSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [authors] search authors
         * @param {string} [userId] user id you want to filter by
         * @param {StudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
         * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
         * @param {StudiesGetLevelEnum} [level] select between studies with group results or meta results
         * @param {string} [pmid] search for particular pmid
         * @param {string} [doi] search for study with specific doi
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: any, source?: StudiesGetSourceEnum, authors?: string, userId?: string, dataType?: StudiesGetDataTypeEnum, studysetOwner?: string, level?: StudiesGetLevelEnum, pmid?: string, doi?: string, flat?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<StudyList> {
            return localVarFp.studiesGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, source, authors, userId, dataType, studysetOwner, level, pmid, doi, flat, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a study
         * @summary DELETE a study
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.studiesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a study.
         * @summary GET a study
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
         * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdGet(id: string, nested?: boolean, studysetOwner?: string, flat?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<StudyReturn> {
            return localVarFp.studiesIdGet(id, nested, studysetOwner, flat, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a study.
         * @summary PUT/update a study
         * @param {string} id 
         * @param {StudyRequest} [studyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdPut(id: string, studyRequest?: StudyRequest, options?: RawAxiosRequestConfig): AxiosPromise<StudyReturn> {
            return localVarFp.studiesIdPut(id, studyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a study
         * @summary POST/create a study
         * @param {StudiesPostSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {StudyRequest} [studyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesPost(source?: StudiesPostSourceEnum, sourceId?: string, studyRequest?: StudyRequest, options?: RawAxiosRequestConfig): AxiosPromise<StudyReturn> {
            return localVarFp.studiesPost(source, sourceId, studyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudiesApi - object-oriented interface
 * @export
 * @class StudiesApi
 * @extends {BaseAPI}
 */
export class StudiesApi extends BaseAPI {
    /**
     * 
     * @summary 
     * @param {Array<string>} [featureFilter] Filter studies by feature content. Format: \&quot;PipelineName[:version]:field_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:predictions.age_mean&gt;20\&quot; (specific version)   - \&quot;TestPipeline:groups.diagnosis&#x3D;ADHD\&quot; (latest version)  Field path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
     * @param {Array<string>} [pipelineConfig] Filter studies by pipeline config content. Format: \&quot;PipelineName[:version]:config_path&#x3D;value\&quot;. Examples:   - \&quot;TestPipeline:1.0.0:settings.min_age&#x3D;20\&quot; (specific version)   - \&quot;TestPipeline:model.type&#x3D;linear\&quot; (latest version)  Config path supports array notation with [], regex search with ~, and comparisons with &#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;. 
     * @param {string} [featureDisplay] display features from pipelines
     * @param {boolean} [featureFlatten] 
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {string} [authors] search authors
     * @param {BaseStudiesGetLevelEnum} [level] select between studies with group results or meta results
     * @param {BaseStudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
     * @param {string} [publication] search for papers from a particular journal
     * @param {string} [pmid] search for particular pmid
     * @param {string} [doi] search for study with specific doi
     * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
     * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public baseStudiesGet(featureFilter?: Array<string>, pipelineConfig?: Array<string>, featureDisplay?: string, featureFlatten?: boolean, search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, authors?: string, level?: BaseStudiesGetLevelEnum, dataType?: BaseStudiesGetDataTypeEnum, publication?: string, pmid?: string, doi?: string, flat?: boolean, info?: boolean, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).baseStudiesGet(featureFilter, pipelineConfig, featureDisplay, featureFlatten, search, sort, page, desc, pageSize, name, description, authors, level, dataType, publication, pmid, doi, flat, info, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Your GET endpoint
     * @param {string} id 
     * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
     * @param {boolean} [info] show additional for endpoint-object relationships without being fully nested. Incompatible with nested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public baseStudiesIdGet(id: string, flat?: boolean, info?: boolean, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).baseStudiesIdGet(id, flat, info, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} id 
     * @param {BaseStudy} [baseStudy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public baseStudiesIdPut(id: string, baseStudy?: BaseStudy, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).baseStudiesIdPut(id, baseStudy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {BaseStudiesPostRequest} [baseStudiesPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public baseStudiesPost(baseStudiesPostRequest?: BaseStudiesPostRequest, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).baseStudiesPost(baseStudiesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List studies
     * @summary GET a list of studies
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {string} [sourceId] id of the resource you are either filtering/copying on
     * @param {any} [unique] whether to list clones with originals
     * @param {StudiesGetSourceEnum} [source] the source of the resource you would like to filter/copy from
     * @param {string} [authors] search authors
     * @param {string} [userId] user id you want to filter by
     * @param {StudiesGetDataTypeEnum} [dataType] whether searching for studies that contain coordinates, images, or both
     * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
     * @param {StudiesGetLevelEnum} [level] select between studies with group results or meta results
     * @param {string} [pmid] search for particular pmid
     * @param {string} [doi] search for study with specific doi
     * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public studiesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: any, source?: StudiesGetSourceEnum, authors?: string, userId?: string, dataType?: StudiesGetDataTypeEnum, studysetOwner?: string, level?: StudiesGetLevelEnum, pmid?: string, doi?: string, flat?: boolean, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).studiesGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, source, authors, userId, dataType, studysetOwner, level, pmid, doi, flat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a study
     * @summary DELETE a study
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public studiesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).studiesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a study.
     * @summary GET a study
     * @param {string} id 
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {string} [studysetOwner] for all studies filter which studysets are listed based on who owns the studyset
     * @param {boolean} [flat] do not return any embedded relationships. When set, it is incompatible with nested. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public studiesIdGet(id: string, nested?: boolean, studysetOwner?: string, flat?: boolean, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).studiesIdGet(id, nested, studysetOwner, flat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a study.
     * @summary PUT/update a study
     * @param {string} id 
     * @param {StudyRequest} [studyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public studiesIdPut(id: string, studyRequest?: StudyRequest, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).studiesIdPut(id, studyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a study
     * @summary POST/create a study
     * @param {StudiesPostSourceEnum} [source] the source of the resource you would like to filter/copy from
     * @param {string} [sourceId] id of the resource you are either filtering/copying on
     * @param {StudyRequest} [studyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public studiesPost(source?: StudiesPostSourceEnum, sourceId?: string, studyRequest?: StudyRequest, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).studiesPost(source, sourceId, studyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const BaseStudiesGetLevelEnum = {
    Group: 'group',
    Meta: 'meta'
} as const;
export type BaseStudiesGetLevelEnum = typeof BaseStudiesGetLevelEnum[keyof typeof BaseStudiesGetLevelEnum];
/**
 * @export
 */
export const BaseStudiesGetDataTypeEnum = {
    Coordinate: 'coordinate',
    Image: 'image',
    Both: 'both'
} as const;
export type BaseStudiesGetDataTypeEnum = typeof BaseStudiesGetDataTypeEnum[keyof typeof BaseStudiesGetDataTypeEnum];
/**
 * @export
 */
export const StudiesGetSourceEnum = {
    Neurostore: 'neurostore',
    Neurovault: 'neurovault',
    Pubmed: 'pubmed',
    Neurosynth: 'neurosynth',
    Neuroquery: 'neuroquery',
    Pubget: 'pubget'
} as const;
export type StudiesGetSourceEnum = typeof StudiesGetSourceEnum[keyof typeof StudiesGetSourceEnum];
/**
 * @export
 */
export const StudiesGetDataTypeEnum = {
    Coordinate: 'coordinate',
    Image: 'image',
    Both: 'both'
} as const;
export type StudiesGetDataTypeEnum = typeof StudiesGetDataTypeEnum[keyof typeof StudiesGetDataTypeEnum];
/**
 * @export
 */
export const StudiesGetLevelEnum = {
    Group: 'group',
    Meta: 'meta'
} as const;
export type StudiesGetLevelEnum = typeof StudiesGetLevelEnum[keyof typeof StudiesGetLevelEnum];
/**
 * @export
 */
export const StudiesPostSourceEnum = {
    Neurostore: 'neurostore',
    Neurovault: 'neurovault',
    Pubmed: 'pubmed',
    Neurosynth: 'neurosynth',
    Neuroquery: 'neuroquery',
    Pubget: 'pubget'
} as const;
export type StudiesPostSourceEnum = typeof StudiesPostSourceEnum[keyof typeof StudiesPostSourceEnum];


/**
 * StudysetsApi - axios parameter creator
 * @export
 */
export const StudysetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of studysets.
         * @summary GET a list of studysets
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {any} [unique] whether to list clones with originals
         * @param {StudysetsGetSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [authors] search authors
         * @param {string} [userId] user id you want to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsGet: async (search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: any, source?: StudysetsGetSourceEnum, authors?: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/studysets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }

            if (unique !== undefined) {
                for (const [key, value] of Object.entries(unique)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (authors !== undefined) {
                localVarQueryParameter['authors'] = authors;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a studyset
         * @summary DELETE a studyset
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studysetsIdDelete', 'id', id)
            const localVarPath = `/studysets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the information of a studyset with the matching studyset ID.
         * @summary GET a studyset
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {boolean} [gzip] return the content as gzipped content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdGet: async (id: string, nested?: boolean, gzip?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studysetsIdGet', 'id', id)
            const localVarPath = `/studysets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            if (gzip !== undefined) {
                localVarQueryParameter['gzip'] = gzip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a studyset.
         * @summary PUT/update a studyset
         * @param {string} id 
         * @param {StudysetRequest} [studysetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdPut: async (id: string, studysetRequest?: StudysetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studysetsIdPut', 'id', id)
            const localVarPath = `/studysets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studysetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a studyset.
         * @summary POST/create a studyset
         * @param {StudysetRequest} [studysetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsPost: async (studysetRequest?: StudysetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/studysets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studysetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudysetsApi - functional programming interface
 * @export
 */
export const StudysetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudysetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of studysets.
         * @summary GET a list of studysets
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {any} [unique] whether to list clones with originals
         * @param {StudysetsGetSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [authors] search authors
         * @param {string} [userId] user id you want to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studysetsGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: any, source?: StudysetsGetSourceEnum, authors?: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudysetList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studysetsGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, source, authors, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudysetsApi.studysetsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete a studyset
         * @summary DELETE a studyset
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studysetsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studysetsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudysetsApi.studysetsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the information of a studyset with the matching studyset ID.
         * @summary GET a studyset
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {boolean} [gzip] return the content as gzipped content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studysetsIdGet(id: string, nested?: boolean, gzip?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudysetReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studysetsIdGet(id, nested, gzip, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudysetsApi.studysetsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a studyset.
         * @summary PUT/update a studyset
         * @param {string} id 
         * @param {StudysetRequest} [studysetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studysetsIdPut(id: string, studysetRequest?: StudysetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudysetReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studysetsIdPut(id, studysetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudysetsApi.studysetsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a studyset.
         * @summary POST/create a studyset
         * @param {StudysetRequest} [studysetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studysetsPost(studysetRequest?: StudysetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudysetReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studysetsPost(studysetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudysetsApi.studysetsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StudysetsApi - factory interface
 * @export
 */
export const StudysetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudysetsApiFp(configuration)
    return {
        /**
         * Get a list of studysets.
         * @summary GET a list of studysets
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {any} [unique] whether to list clones with originals
         * @param {StudysetsGetSourceEnum} [source] the source of the resource you would like to filter/copy from
         * @param {string} [authors] search authors
         * @param {string} [userId] user id you want to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: any, source?: StudysetsGetSourceEnum, authors?: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<StudysetList> {
            return localVarFp.studysetsGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, source, authors, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a studyset
         * @summary DELETE a studyset
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.studysetsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the information of a studyset with the matching studyset ID.
         * @summary GET a studyset
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {boolean} [gzip] return the content as gzipped content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdGet(id: string, nested?: boolean, gzip?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<StudysetReturn> {
            return localVarFp.studysetsIdGet(id, nested, gzip, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a studyset.
         * @summary PUT/update a studyset
         * @param {string} id 
         * @param {StudysetRequest} [studysetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsIdPut(id: string, studysetRequest?: StudysetRequest, options?: RawAxiosRequestConfig): AxiosPromise<StudysetReturn> {
            return localVarFp.studysetsIdPut(id, studysetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a studyset.
         * @summary POST/create a studyset
         * @param {StudysetRequest} [studysetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studysetsPost(studysetRequest?: StudysetRequest, options?: RawAxiosRequestConfig): AxiosPromise<StudysetReturn> {
            return localVarFp.studysetsPost(studysetRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudysetsApi - object-oriented interface
 * @export
 * @class StudysetsApi
 * @extends {BaseAPI}
 */
export class StudysetsApi extends BaseAPI {
    /**
     * Get a list of studysets.
     * @summary GET a list of studysets
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {string} [sourceId] id of the resource you are either filtering/copying on
     * @param {any} [unique] whether to list clones with originals
     * @param {StudysetsGetSourceEnum} [source] the source of the resource you would like to filter/copy from
     * @param {string} [authors] search authors
     * @param {string} [userId] user id you want to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudysetsApi
     */
    public studysetsGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: any, source?: StudysetsGetSourceEnum, authors?: string, userId?: string, options?: RawAxiosRequestConfig) {
        return StudysetsApiFp(this.configuration).studysetsGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, source, authors, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a studyset
     * @summary DELETE a studyset
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudysetsApi
     */
    public studysetsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return StudysetsApiFp(this.configuration).studysetsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the information of a studyset with the matching studyset ID.
     * @summary GET a studyset
     * @param {string} id 
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {boolean} [gzip] return the content as gzipped content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudysetsApi
     */
    public studysetsIdGet(id: string, nested?: boolean, gzip?: boolean, options?: RawAxiosRequestConfig) {
        return StudysetsApiFp(this.configuration).studysetsIdGet(id, nested, gzip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a studyset.
     * @summary PUT/update a studyset
     * @param {string} id 
     * @param {StudysetRequest} [studysetRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudysetsApi
     */
    public studysetsIdPut(id: string, studysetRequest?: StudysetRequest, options?: RawAxiosRequestConfig) {
        return StudysetsApiFp(this.configuration).studysetsIdPut(id, studysetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a studyset.
     * @summary POST/create a studyset
     * @param {StudysetRequest} [studysetRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudysetsApi
     */
    public studysetsPost(studysetRequest?: StudysetRequest, options?: RawAxiosRequestConfig) {
        return StudysetsApiFp(this.configuration).studysetsPost(studysetRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const StudysetsGetSourceEnum = {
    Neurostore: 'neurostore',
    Neurovault: 'neurovault',
    Pubmed: 'pubmed',
    Neurosynth: 'neurosynth',
    Neuroquery: 'neuroquery',
    Pubget: 'pubget'
} as const;
export type StudysetsGetSourceEnum = typeof StudysetsGetSourceEnum[keyof typeof StudysetsGetSourceEnum];


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get list of users
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get an individual user
         * @summary Individual User Profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update an individual user
         * @summary Update Individual Profile
         * @param {string} id 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut: async (id: string, user?: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdPut', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a user
         * @summary 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (user?: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * get list of users
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get an individual user
         * @summary Individual User Profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update an individual user
         * @summary Update Individual Profile
         * @param {string} id 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdPut(id: string, user?: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdPut(id, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create a user
         * @summary 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(user?: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * get list of users
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options?: RawAxiosRequestConfig): AxiosPromise<UserList> {
            return localVarFp.usersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * get an individual user
         * @summary Individual User Profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * update an individual user
         * @summary Update Individual Profile
         * @param {string} id 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut(id: string, user?: User, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersIdPut(id, user, options).then((request) => request(axios, basePath));
        },
        /**
         * create a user
         * @summary 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(user?: User, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersPost(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * get list of users
     * @summary Your GET endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get an individual user
     * @summary Individual User Profile
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdGet(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update an individual user
     * @summary Update Individual Profile
     * @param {string} id 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdPut(id: string, user?: User, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersIdPut(id, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create a user
     * @summary 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersPost(user?: User, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersPost(user, options).then((request) => request(this.axios, this.basePath));
    }
}



